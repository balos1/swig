<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>SWIG and Fortran</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <style type="text/css">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; position: absolute; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; }
pre.numberSource a.sourceLine:empty
  { position: absolute; }
pre.numberSource a.sourceLine::before
  { content: attr(data-line-number);
    position: absolute; left: -5em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
  <style type="text/css">
  /* from div.code */
  pre.swig {
    border-style: solid; 
    border-width: 1px; 
    padding: 2pt; 
    margin-left: 4em;
    margin-right: 4em;
    background-color: #F0FFFF;
    font-family: "Courier New", Courier, "Courier 10 Pitch", monospace;
  }    
  /* from div.targetlang */
  pre.fortran {
    border-style: solid; 
    border-width: 1px; 
    padding: 2pt; 
    margin-left: 4em;
    margin-right: 4em;
    background-color: #d7f6bb;
    font-family: "Courier New", Courier, "Courier 10 Pitch", monospace;
  }
  </style>
</head>
<body>
<header>
<h1 class="title">SWIG and Fortran</h1>
</header>
<nav id="TOC">
<ul>
<li><a href="#overview">Overview</a></li>
<li><a href="#fundamental-concepts">Fundamental concepts</a><ul>
<li><a href="#nomenclature">Nomenclature</a></li>
<li><a href="#identifiers">Identifiers</a></li>
<li><a href="#running-swig">Running SWIG</a></li>
<li><a href="#compiling-a-simple-fortran-program">Compiling a simple Fortran program</a></li>
<li><a href="#compiling-more-complex-fortrancc-programs">Compiling more complex Fortran/C/C++ programs</a></li>
</ul></li>
<li><a href="#basic-fortranc-data-type-interoperability">Basic Fortran/C data type interoperability</a><ul>
<li><a href="#fundamental-types">Fundamental types</a></li>
<li><a href="#pointers-and-references">Pointers and references</a></li>
<li><a href="#strings">Strings</a></li>
<li><a href="#arrays">Arrays</a></li>
<li><a href="#classes-and-structs">Classes and structs</a></li>
<li><a href="#ignored-or-unimplemented-forward-declared-structs-and-classes">Ignored or unimplemented forward-declared structs and classes</a></li>
<li><a href="#enumerations">Enumerations</a></li>
<li><a href="#function-pointers">Function pointers</a></li>
<li><a href="#handles-and-other-oddities">Handles and other oddities</a></li>
</ul></li>
<li><a href="#basic-cc-features">Basic C/C++ features</a><ul>
<li><a href="#functions">Functions</a></li>
<li><a href="#global-variables">Global variables</a><ul>
<li><a href="#global-constants">Global constants</a></li>
</ul></li>
<li><a href="#classes">Classes</a><ul>
<li><a href="#constructors-and-destructors">Constructors and Destructors</a></li>
<li><a href="#member-functions">Member functions</a></li>
<li><a href="#member-data">Member data</a></li>
<li><a href="#inheritance">Inheritance</a></li>
</ul></li>
<li><a href="#exceptions">Exceptions</a></li>
<li><a href="#shared-pointers">Shared pointers</a></li>
</ul></li>
<li><a href="#typemaps">Typemaps</a><ul>
<li><a href="#fortran-proxy-datatype-translation">Fortran proxy datatype translation</a></li>
<li><a href="#special-overrides-for-return-variables">Special overrides for return variables</a></li>
<li><a href="#allocating-local-fortran-variables-in-wrapper-codes">Allocating local Fortran variables in wrapper codes</a></li>
<li><a href="#special-class-typemaps">Special class typemaps</a></li>
<li><a href="#fortran-interoperability">Fortran interoperability</a></li>
</ul></li>
<li><a href="#direct-c-binding">Direct C binding</a><ul>
<li><a href="#generating-c-bound-fortran-types-from-c-structs">Generating C-bound Fortran types from C structs</a></li>
<li><a href="#interfaces-with-fortran-c-bound-types">Interfaces with Fortran C-bound types</a></li>
<li><a href="#generating-direct-fortran-interfaces-to-c-functions">Generating direct Fortran interfaces to C functions</a></li>
</ul></li>
<li><a href="#swig-generated-fortran-derived-types">SWIG-generated Fortran derived types</a><ul>
<li><a href="#memory-management">Memory management</a></li>
<li><a href="#function-overloading">Function overloading</a></li>
<li><a href="#opaque-class-types">Opaque class types</a></li>
<li><a href="#proxy-class-wrapper-code">Proxy class wrapper code</a></li>
<li><a href="#finalization">Finalization</a></li>
</ul></li>
<li><a href="#advanced">Advanced</a><ul>
<li><a href="#fragments">Fragments</a></li>
<li><a href="#known-issues">Known Issues</a></li>
</ul></li>
</ul>
</nav>
<!--
This document is formatted with [Github-flavored
Markdown](https://github.github.com/gfm/)

Run with:
    pandoc --from=gfm  --metadata title="SWIG and Fortran" \
    --toc --standalone -H style.css -o ../Fortran.html Fortran.md

Authored by Seth R Johnson
-->

<h1 id="overview">Overview</h1>
<p>This chapter describes how to create interfaces to C and C++ data and functions in the target language of Fortran, a highly static, long-lived scientific programming language. The primary motivation for adding the Fortran language to SWIG is to provide an automated means to adapt massively parallel scientific codes to modern solvers and GPU-accelerated kernels in the Trilinos numerical library package. But in addition to this useful capability, SWIG-Fortran has potential to simplify and accelerate numerous existing Fortran codes that do not require advanced numerical solvers. By implementing automated coupling of C++ libraries to Fortran, we open up a new world of capability to Fortran users.</p>
<h1 id="fundamental-concepts">Fundamental concepts</h1>
<p>SWIG generates simple, flat C functions that provide access to underlying C/C++ data and functions that may operate on complex data types. Fortran 2003 introduced features designed to finally provide standardized interactions between Fortran and ANSI C. The wrapper functions generated by SWIG-Fortran take and return only these <code>ISO_C_BINDING</code>-compatible data types. These functions are responsible for converting any complex C datatypes to simpler ones compatible with Fortran.</p>
<p>In addition to generating a C++ file of wrapper code, SWIG generates a Fortran module (one per <code>%module</code> SWIG directive). In the private &quot;interface&quot; section of this module, SWIG generates function interface declarations with the <code>BIND(C)</code> qualifier that exactly mirror the generated wrapper functions. In SWIG, all of the C-generated wrapper functions are prefixed with <code>swigc_</code>, so all of these interface functions likewise start with <code>swigc_</code>.</p>
<p>Finally, SWIG generates additional Fortran code that translates the simple function arguments and return values into their Fortran equivalents. For simple data types this conversion is simply assignment, but other complex transformations can be performed that allow better native integration of C++ with Fortran. For example, a <code>const int[3]&amp;</code> return value can be transformed to Fortran length-3 array <code>pointer</code> instead of being left as an opaque C pointer.</p>
<p>SWIG also generates &quot;proxy&quot; classes: thin Fortran 2003 TYPE declarations that bind <code>swigc_</code> functions to manipulate C++ class instances in Fortran.</p>
<h2 id="nomenclature">Nomenclature</h2>
<p>The terminology in C/C++ and Fortran is different enough to be potentially confusing to a user of either one language or the other. The author is much more familiar with C++ than Fortran but has endeavored to use the correct Fortran terms when describing the Fortran implementation. The following table roughly illustrates some of the differences between the two languages:</p>
<table>
<thead>
<tr class="header">
<th>C/C++</th>
<th>Fortran</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>struct/class</td>
<td>derived type</td>
</tr>
<tr class="even">
<td>function</td>
<td>procedure</td>
</tr>
<tr class="odd">
<td>member function</td>
<td>type-bound procedure</td>
</tr>
<tr class="even">
<td>function that returns void</td>
<td>subroutine</td>
</tr>
<tr class="odd">
<td>function that returns non-void</td>
<td>function</td>
</tr>
<tr class="even">
<td>overloaded function</td>
<td>generic interface</td>
</tr>
<tr class="odd">
<td>floating point number</td>
<td>real</td>
</tr>
<tr class="even">
<td>fundamental type</td>
<td>intrinsic type</td>
</tr>
<tr class="odd">
<td>derived type</td>
<td>extended type</td>
</tr>
<tr class="even">
<td>class instance</td>
<td>structure</td>
</tr>
</tbody>
</table>
<h2 id="identifiers">Identifiers</h2>
<p>C and C++ have different rules for identifiers (i.e. variable names, function names, class names) than Fortran. The following restrictions apply to Fortran that do not apply to C and C++:</p>
<ul>
<li>Names are <strong>case insensitive</strong></li>
<li>Names may not begin with an underscore</li>
<li>Names may be no longer than 63 characters</li>
</ul>
<p>SWIG automatically renames identifiers that start with a leading underscore. It keeps a symbol table of publicly accessible Fortran identifiers (as their lower-cased, renamed versions) and warns about and ignores duplicate names.</p>
<p>There is also no &quot;namespace&quot; concept in Fortran 2003 aside from defining procedures and types in separate modules. (Fortran 2008 supports submodules, but these are more akin to private namespaces inside a translation unit in C++.) Keep in mind that the extremely flexible <code>%rename</code> directive can be used to adjust the symbolic names created in SWIG.</p>
<h2 id="running-swig">Running SWIG</h2>
<p>Suppose that we have a SWIG interface file <code>example.i</code> with the following contents:</p>
<pre class="swig"><code>/* File: example.i */
%module forexample

%{
/* include header */
#include &quot;cexample.h&quot;
%}

%include &quot;cexample.h&quot;
</code></pre>
<p>(and <code>cexample.h</code> contains the simple function declaration:)</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="dt">int</span> fact(<span class="dt">int</span> n);</a></code></pre></div>
<p>To generate SWIG Fortran wrappers for this file, run</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode sh"><code class="sourceCode bash"><a class="sourceLine" id="cb3-1" data-line-number="1">$ <span class="ex">swig</span> -fortran example.i</a></code></pre></div>
<p>and SWIG will create two files: a C interface file containing something like</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="co">/* SNIP */</span></a>
<a class="sourceLine" id="cb4-2" data-line-number="2"><span class="co">/* include header */</span></a>
<a class="sourceLine" id="cb4-3" data-line-number="3"><span class="pp">#include </span><span class="im">&quot;cexample.h&quot;</span></a>
<a class="sourceLine" id="cb4-4" data-line-number="4"><span class="co">/* SNIP */</span></a>
<a class="sourceLine" id="cb4-5" data-line-number="5">SWIGEXPORT <span class="dt">int</span> swigc_fact(<span class="dt">int</span> <span class="dt">const</span> *farg1) {</a>
<a class="sourceLine" id="cb4-6" data-line-number="6">  <span class="dt">int</span> fresult;</a>
<a class="sourceLine" id="cb4-7" data-line-number="7">  <span class="dt">int</span> arg1;</a>
<a class="sourceLine" id="cb4-8" data-line-number="8">  <span class="dt">int</span> result;</a>
<a class="sourceLine" id="cb4-9" data-line-number="9">  </a>
<a class="sourceLine" id="cb4-10" data-line-number="10">  arg1 = *farg1;</a>
<a class="sourceLine" id="cb4-11" data-line-number="11">  result = (<span class="dt">int</span>)fact(arg1);</a>
<a class="sourceLine" id="cb4-12" data-line-number="12">  fresult = result;</a>
<a class="sourceLine" id="cb4-13" data-line-number="13">  <span class="cf">return</span> fresult;</a>
<a class="sourceLine" id="cb4-14" data-line-number="14">}</a>
<a class="sourceLine" id="cb4-15" data-line-number="15"><span class="co">/* SNIP */</span></a></code></pre></div>
<p>and a Fortran interface file with something like:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode fortran"><code class="sourceCode fortran"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="kw">module</span> forexample</a>
<a class="sourceLine" id="cb5-2" data-line-number="2"> <span class="kw">use</span>, <span class="kw">intrinsic</span> <span class="dt">::</span> ISO_C_BINDING</a>
<a class="sourceLine" id="cb5-3" data-line-number="3"> <span class="kw">implicit</span> <span class="kw">none</span></a>
<a class="sourceLine" id="cb5-4" data-line-number="4"> <span class="dt">public</span> <span class="dt">::</span> fact</a>
<a class="sourceLine" id="cb5-5" data-line-number="5"><span class="dt">private</span></a>
<a class="sourceLine" id="cb5-6" data-line-number="6"><span class="kw">interface</span></a>
<a class="sourceLine" id="cb5-7" data-line-number="7"> <span class="kw">function</span> swigc_fact(farg1) <span class="kw">&amp;</span></a>
<a class="sourceLine" id="cb5-8" data-line-number="8"> bind(C, name<span class="kw">=</span><span class="st">&quot;swigc_fact&quot;</span>) <span class="kw">&amp;</span></a>
<a class="sourceLine" id="cb5-9" data-line-number="9">  <span class="kw">result</span>(fresult)</a>
<a class="sourceLine" id="cb5-10" data-line-number="10">  <span class="kw">use</span>, <span class="kw">intrinsic</span> <span class="dt">::</span> ISO_C_BINDING</a>
<a class="sourceLine" id="cb5-11" data-line-number="11">  <span class="dt">integer(C_INT)</span> <span class="dt">::</span> fresult</a>
<a class="sourceLine" id="cb5-12" data-line-number="12">  <span class="dt">integer(C_INT)</span>, <span class="dt">intent(in)</span> <span class="dt">::</span> farg1</a>
<a class="sourceLine" id="cb5-13" data-line-number="13"> <span class="kw">end function</span></a>
<a class="sourceLine" id="cb5-14" data-line-number="14"><span class="kw">end interface</span></a>
<a class="sourceLine" id="cb5-15" data-line-number="15"><span class="co">contains</span></a>
<a class="sourceLine" id="cb5-16" data-line-number="16"> <span class="kw">function</span> fact(n) <span class="kw">&amp;</span></a>
<a class="sourceLine" id="cb5-17" data-line-number="17">  <span class="kw">result</span>(swig_result)</a>
<a class="sourceLine" id="cb5-18" data-line-number="18">  <span class="kw">use</span>, <span class="kw">intrinsic</span> <span class="dt">::</span> ISO_C_BINDING</a>
<a class="sourceLine" id="cb5-19" data-line-number="19">  <span class="dt">integer(C_INT)</span> <span class="dt">::</span> swig_result</a>
<a class="sourceLine" id="cb5-20" data-line-number="20">  <span class="dt">integer(C_INT)</span>, <span class="dt">intent(in)</span> <span class="dt">::</span> n</a>
<a class="sourceLine" id="cb5-21" data-line-number="21">  <span class="dt">integer(C_INT)</span> <span class="dt">::</span> fresult </a>
<a class="sourceLine" id="cb5-22" data-line-number="22">  <span class="dt">integer(C_INT)</span> <span class="dt">::</span> farg1 </a>
<a class="sourceLine" id="cb5-23" data-line-number="23">  farg1 <span class="kw">=</span> n</a>
<a class="sourceLine" id="cb5-24" data-line-number="24">  fresult <span class="kw">=</span> swigc_fact(farg1)</a>
<a class="sourceLine" id="cb5-25" data-line-number="25">  swig_result <span class="kw">=</span> fresult</a>
<a class="sourceLine" id="cb5-26" data-line-number="26"> <span class="kw">end function</span></a>
<a class="sourceLine" id="cb5-27" data-line-number="27"><span class="kw">end module</span> forexample</a></code></pre></div>
<p>The <code>%module</code> declaration in the <code>.i</code> file resulted in the file names <code>forexample.f90</code> and the name in <code>module forexample</code>; file name <code>example.i</code> resulted in the C wrapper file by default being named <code>example_wrap.c</code>, and the <code>#include</code> command was explicitly inserted into the C wrapper file <code>example_wrap.c</code>. The <code>%include</code> command in the <code>.i</code> file directed SWIG to parse the header file <code>cexample.h</code> and generate an interface for the function declaration that it discovered.</p>
<p>In the generated C wrapper code above, <code>int swigc_fact(int const *farg1)</code> is the wrapper code generated by SWIG to provide a Fortran-compatible interface with the C function <code>fact</code>; the <code>function swigc_fact(farg1)</code> interface in Fortran is the exact equivalent of that C function; and the &quot;public&quot; function <code>fact</code> in the <code>contains</code> section of the Fortran module is the Fortran proxy function generated by SWIG.</p>
<p>Note that since this function takes and returns simple data types, the C and Fortran wrapper functions have some code that could be easily simplified by hand. However, for more complex data types, SWIG shows its power by generating complex expressions that seamlessly translate between C and Fortran data types without requiring user intervention.</p>
<h2 id="compiling-a-simple-fortran-program">Compiling a simple Fortran program</h2>
<p>Several examples are provided in the SWIG source code under <code>Examples/fortran/</code>. In the <code>barefunctions</code> example, the Fortran <code>main</code> program can be compiled using the following sequence of commands:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode sh"><code class="sourceCode bash"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="ex">swig</span> -fortran -c++ bare.i</a>
<a class="sourceLine" id="cb6-2" data-line-number="2"><span class="va">$CXX</span> <span class="ex">-c</span> bare_wrap.cxx</a>
<a class="sourceLine" id="cb6-3" data-line-number="3"><span class="va">$CXX</span> <span class="ex">-c</span> bare.cxx -o barecxx.o</a>
<a class="sourceLine" id="cb6-4" data-line-number="4"><span class="va">$FC</span> <span class="ex">gfortran</span> -c bare.f90</a>
<a class="sourceLine" id="cb6-5" data-line-number="5"><span class="va">$FC</span> <span class="ex">runme.f90</span> bare.o bare_wrap.o barecxx.o -lstdc++ -o run.exe</a></code></pre></div>
<p>Note that since this was a C++ program, the <code>c++</code> option must be passed to SWIG and <code>-lstdc++</code> must be passed to the final link command.</p>
<h2 id="compiling-more-complex-fortrancc-programs">Compiling more complex Fortran/C/C++ programs</h2>
<p>The figure below shows how C++, SWIG, and Fortran code can be integrated into libraries and linked to form executables. The file icons are user-written files; circles are executables; flat cylinders are generated on-disk files; and the final box is the executable. The arrow signifies &quot;generates&quot; or &quot;is used by.&quot;</p>
<p><img src="fig/swig-fortran-data.png" alt="SWIG python data flow" height="504"
width="352"/></p>
<p>We provide CMake modules and commands to simplify this process; again, see the example directories for usage instructions.</p>
<!-- ###################################################################### -->

<h1 id="basic-fortranc-data-type-interoperability">Basic Fortran/C data type interoperability</h1>
<p>The Fortran SWIG module relies on Fortran 2003's C interoperability features, both the <code>ISO_C_BINDING</code> intrinsic module and the specifications of the standard. Every effort has been made to conform to the standard in the translation layer between C++ and Fortran and to eliminate potential pitfalls of interoperability.</p>
<p>We anticipate that future extensions of Fortran/C interoperability will increase the capability of the SWIG wrapper interface. However, many features of C and C++ are outside the scope of Fortran's interoperability features. Even some features that <em>are</em> interoperable,such as enumerations and structs, have capabilities that do not map between the two languages. With SWIG-Fortran we attempt to extend the Fortran/C++ mapping as much as possible, keeping in mind that Fortran and C are inherently different languages designed at different times with different purposes in mind.</p>
<h2 id="fundamental-types">Fundamental types</h2>
<p>SWIG maps a number of the fundamental C types to their ISO Fortran equivalents via the <code>use, intrinsic :: ISO_C_BINDING</code> statement. The types mapped directly by SWIG are:</p>
<table>
<thead>
<tr class="header">
<th>C type</th>
<th>Fortran type</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>unsigned char</code></td>
<td><code>integer(C_INT8_T)</code></td>
</tr>
<tr class="even">
<td><code>short</code></td>
<td><code>integer(C_SHORT)</code></td>
</tr>
<tr class="odd">
<td><code>unsigned short</code></td>
<td><code>integer(C_SHORT)</code></td>
</tr>
<tr class="even">
<td><code>int</code></td>
<td><code>integer(C_INT)</code></td>
</tr>
<tr class="odd">
<td><code>unsigned int</code></td>
<td><code>integer(C_INT)</code></td>
</tr>
<tr class="even">
<td><code>long</code></td>
<td><code>integer(C_LONG)</code></td>
</tr>
<tr class="odd">
<td><code>unsigned long</code></td>
<td><code>integer(C_LONG)</code></td>
</tr>
<tr class="even">
<td><code>long long</code></td>
<td><code>integer(C_LONG_LONG)</code></td>
</tr>
<tr class="odd">
<td><code>size_t</code></td>
<td><code>integer(C_SIZE_T)</code></td>
</tr>
<tr class="even">
<td><code>float</code></td>
<td><code>real(C_FLOAT)</code></td>
</tr>
<tr class="odd">
<td><code>double</code></td>
<td><code>real(C_DOUBLE)</code></td>
</tr>
<tr class="even">
<td><code>void*</code></td>
<td><code>type(C_PTR)</code></td>
</tr>
</tbody>
</table>
<p>Pointers and references to the fundamental types are returned as scalar Fortran pointers: because the C return value does not contain any information about the shape of the data being pointed to, it is not possible to directly construct an array from a pointed-to value.</p>
<p>However, advanced typemaps can be constructed (and indeed are provided by the SWIG Fortran library) that <em>can</em> return that information or extend the Fortran interface to obtain the additional information needed to return an array pointer.</p>
<p>The astute reader may notice the omission of <code>C_BOOL</code> from the above table. Because of the different treatment of booleans in C and Fortran, guaranteeing the sizes of the <code>bool</code> is equivalent in the two languages does <em>not</em> guarantee the equivalence of their values. See <a href="https://software.intel.com/en-us/forums/intel-fortran-compiler-for-linux-and-mac-os-x/topic/594856">this discussion topic</a> for details of the subtle compatibility, but in brief, Fortran's <code>.true.</code> is defined by having the least significant bit set to <code>1</code>, whereas C defines it as any nonzero value. So the value <code>2</code> would be <code>true</code> in C but <code>false</code> in Fortran. A special typemap inserts wrapper code to explicitly convert booleans between the two languages.</p>
<p>The built-in type wrapping also omits standard C character <code>char</code> to prevent ambiguity of wrapping character arrays (<code>char*</code> or <code>CHARACTER, DIMENSION(:)</code>) from strings (<code>char*</code> or <code>CHARACTER(LEN=*)</code>).</p>
<p>A more complete set of typemaps for the full set of integer types available in <code>&lt;stdint.h&gt;</code> can be used by `%include <cstdint></p>
<h2 id="pointers-and-references">Pointers and references</h2>
<p>C pointers and mutable references are treated as Fortran pointers. Suppose a C function that returns a pointer to an array element at a given index:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="dt">double</span>* get_array_element(<span class="dt">int</span> x);</a></code></pre></div>
<p>This generates the following Fortran interface:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode fortran"><code class="sourceCode fortran"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="kw">function</span> get_array_element(x) <span class="kw">&amp;</span></a>
<a class="sourceLine" id="cb8-2" data-line-number="2">      <span class="kw">result</span>(swig_result)</a>
<a class="sourceLine" id="cb8-3" data-line-number="3">  <span class="kw">use</span>, <span class="kw">intrinsic</span> <span class="dt">::</span> ISO_C_BINDING</a>
<a class="sourceLine" id="cb8-4" data-line-number="4"><span class="dt">  real(C_DOUBLE)</span>, <span class="dt">pointer</span> <span class="dt">::</span> swig_result</a>
<a class="sourceLine" id="cb8-5" data-line-number="5">  <span class="dt">integer(C_INT)</span>, <span class="dt">intent(in)</span> <span class="dt">::</span> x</a>
<a class="sourceLine" id="cb8-6" data-line-number="6">  <span class="dt">type(C_PTR)</span> <span class="dt">::</span> fresult </a>
<a class="sourceLine" id="cb8-7" data-line-number="7">  <span class="dt">integer(C_INT)</span> <span class="dt">::</span> farg1 </a>
<a class="sourceLine" id="cb8-8" data-line-number="8"></a>
<a class="sourceLine" id="cb8-9" data-line-number="9">  farg1 <span class="kw">=</span> x</a>
<a class="sourceLine" id="cb8-10" data-line-number="10">  fresult <span class="kw">=</span> swigc_get_array_element(farg1)</a>
<a class="sourceLine" id="cb8-11" data-line-number="11">  <span class="kw">call</span> c_f_pointer(fresult, swig_result)</a>
<a class="sourceLine" id="cb8-12" data-line-number="12"><span class="kw">end function</span></a></code></pre></div>
<p>To set the element at array index 2 to the value 512,</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode fortran"><code class="sourceCode fortran"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="dt">real(C_DOUBLE)</span>, <span class="dt">pointer</span> <span class="dt">::</span> rptr</a>
<a class="sourceLine" id="cb9-2" data-line-number="2">rptr <span class="kw">=</span><span class="op">&gt;</span> get_array_element(<span class="dv">2</span>)</a>
<a class="sourceLine" id="cb9-3" data-line-number="3">rptr <span class="kw">=</span> <span class="fl">512.0d0</span></a></code></pre></div>
<p>Note, and this is <strong>very important</strong>, that a function returning a pointer must not be <em>assigned</em>; the <em>pointer assignment</em> operator <code>=&gt;</code> must be used.</p>
<p>Mutable references are treated identically. However, <em>const</em> references to primitive types are treated as values:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode c++"><code class="sourceCode cpp"><a class="sourceLine" id="cb10-1" data-line-number="1"><span class="at">const</span> <span class="dt">double</span>&amp; get_const_array_element(<span class="dt">int</span> x);</a></code></pre></div>
<p>will generate</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode fortran"><code class="sourceCode fortran"><a class="sourceLine" id="cb11-1" data-line-number="1"><span class="kw">function</span> get_const_array_element(x) <span class="kw">&amp;</span></a>
<a class="sourceLine" id="cb11-2" data-line-number="2">    <span class="kw">result</span>(swig_result)</a>
<a class="sourceLine" id="cb11-3" data-line-number="3">  <span class="kw">use</span>, <span class="kw">intrinsic</span> <span class="dt">::</span> ISO_C_BINDING</a>
<a class="sourceLine" id="cb11-4" data-line-number="4"><span class="dt">  real(C_DOUBLE)</span> <span class="dt">::</span> swig_result</a>
<a class="sourceLine" id="cb11-5" data-line-number="5">  <span class="dt">integer(C_INT)</span>, <span class="dt">intent(in)</span> <span class="dt">::</span> x</a>
<a class="sourceLine" id="cb11-6" data-line-number="6"><span class="dt">  real(C_DOUBLE)</span> <span class="dt">::</span> fresult </a>
<a class="sourceLine" id="cb11-7" data-line-number="7">  <span class="dt">integer(C_INT)</span> <span class="dt">::</span> farg1 </a>
<a class="sourceLine" id="cb11-8" data-line-number="8"></a>
<a class="sourceLine" id="cb11-9" data-line-number="9">  farg1 <span class="kw">=</span> x</a>
<a class="sourceLine" id="cb11-10" data-line-number="10">  fresult <span class="kw">=</span> swigc_get_const_array_element(farg1)</a>
<a class="sourceLine" id="cb11-11" data-line-number="11">  swig_result <span class="kw">=</span> fresult</a>
<a class="sourceLine" id="cb11-12" data-line-number="12"><span class="kw">end function</span></a></code></pre></div>
<p>which must be called like</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode fortran"><code class="sourceCode fortran"><a class="sourceLine" id="cb12-1" data-line-number="1"><span class="dt">real(C_DOUBLE)</span> <span class="dt">::</span> rval</a>
<a class="sourceLine" id="cb12-2" data-line-number="2">rval <span class="kw">=</span> get_const_array_element(<span class="dv">2</span>)</a></code></pre></div>
<p>Combining the two examples, you could copy value of element 3 to element 2 with the following code block:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode fortran"><code class="sourceCode fortran"><a class="sourceLine" id="cb13-1" data-line-number="1"><span class="dt">real(C_DOUBLE)</span>, <span class="dt">pointer</span> <span class="dt">::</span> rptr</a>
<a class="sourceLine" id="cb13-2" data-line-number="2">rptr <span class="kw">=</span><span class="op">&gt;</span> get_array_element(<span class="dv">2</span>)</a>
<a class="sourceLine" id="cb13-3" data-line-number="3">rptr <span class="kw">=</span> get_const_array_element(<span class="dv">3</span>)</a></code></pre></div>
<p>First the pointer is assigned, then the pointed-to data is assigned.</p>
<h2 id="strings">Strings</h2>
<p>Fortran's interoperability specifications prohibit using <code>C_LOC</code> on variables with length type parameters: thus the standard <code>character(len=*)</code> type cannot be natively passed to C. Instead, SWIG injects small helper functions that convert between strings and arrays of characters. The character arrays are then passed through the interface layer to C, which can reconstruct the full string.</p>
<p>Because the actual Fortran string length is passed to C during this process, character arrays with the null character can be converted to byte objects without unexpected string truncation.</p>
<p>Currently SWIG provides typemaps (see the Typemaps section) that allow transparent conversion between Fortran character arrays and C++ <code>std::string</code> objects. Automatic wrapping for null-terminated C strings (with signature <code>const char*</code>) is not implemented yet, but there is no fundamental obstacle in doing so.</p>
<h2 id="arrays">Arrays</h2>
<p>SWIG supports a subset of direct Fortran array translation. If a single-dimensional array size is explicitly specified in a C function's signature, the corresponding argument will be an explicit-shape Fortran array.</p>
<p>One caution is that occasionally arrays will be defined using nontrivial C expressions rather than explicit integers. Even though these can be evaluated by C at compile time, the unevaluated expression is propagated into the Fortran wrapper code where it will fail.</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb14-1" data-line-number="1"><span class="dt">int</span> global_data1[<span class="dv">8</span>]; <span class="co">/* OK */</span></a>
<a class="sourceLine" id="cb14-2" data-line-number="2"><span class="dt">int</span> global_data2[];  <span class="co">/* OK */</span></a>
<a class="sourceLine" id="cb14-3" data-line-number="3"><span class="dt">int</span> global_data3[<span class="kw">sizeof</span>(<span class="dt">int</span>)];  <span class="co">/* ERROR */</span></a></code></pre></div>
<h2 id="classes-and-structs">Classes and structs</h2>
<p>In C++, the only difference between a <code>struct</code> and a <code>class</code> is the default <em>access specifier</em>: <code>public</code> for <code>struct</code> and <code>private</code> for <code>class</code>. As with the rest of SWIG, only public methods and data are wrapped.</p>
<p>These are both wrapped as <em>derived types</em> in Fortran. By default, these derived types are &quot;proxy&quot; classes, which hold a C pointer to a C++ class instance. Roughly speaking, classes are mapped from</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode c++"><code class="sourceCode cpp"><a class="sourceLine" id="cb15-1" data-line-number="1"><span class="kw">class</span> Foo {</a>
<a class="sourceLine" id="cb15-2" data-line-number="2"><span class="kw">public</span>:</a>
<a class="sourceLine" id="cb15-3" data-line-number="3">  <span class="dt">void</span> bar();</a>
<a class="sourceLine" id="cb15-4" data-line-number="4">};</a></code></pre></div>
<p>becomes</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode fortran"><code class="sourceCode fortran"><a class="sourceLine" id="cb16-1" data-line-number="1"><span class="dt">type</span> <span class="dt">::</span> Foo</a>
<a class="sourceLine" id="cb16-2" data-line-number="2">  <span class="dt">type(SwigClassWrapper)</span>, <span class="dt">public</span> <span class="dt">::</span> swigdata</a>
<a class="sourceLine" id="cb16-3" data-line-number="3"><span class="co">contains</span></a>
<a class="sourceLine" id="cb16-4" data-line-number="4">  <span class="kw">procedure</span> <span class="dt">::</span> bar <span class="kw">=</span><span class="op">&gt;</span> swigf_Foo_bar</a>
<a class="sourceLine" id="cb16-5" data-line-number="5"><span class="dt">end type</span></a></code></pre></div>
<p>In certain circumstances, C classes can be wrapped natively as Fortran <code>BIND(C)</code> derived types, so that the underlying data can be shared between C and Fortran without any wrapping needed. Specified standard-layout structs can use the <code>%bindc</code> feature to translate</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode c++"><code class="sourceCode cpp"><a class="sourceLine" id="cb17-1" data-line-number="1"><span class="kw">struct</span> BasicStruct {</a>
<a class="sourceLine" id="cb17-2" data-line-number="2">  <span class="dt">int</span> foo;</a>
<a class="sourceLine" id="cb17-3" data-line-number="3">  <span class="dt">double</span> bar;</a>
<a class="sourceLine" id="cb17-4" data-line-number="4">};</a></code></pre></div>
<p>to</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode fortran"><code class="sourceCode fortran"><a class="sourceLine" id="cb18-1" data-line-number="1"><span class="dt">type</span>, bind(C) <span class="dt">::</span> BasicStruct</a>
<a class="sourceLine" id="cb18-2" data-line-number="2">  <span class="dt">integer(C_INT)</span>, <span class="dt">public</span> <span class="dt">::</span> foo</a>
<a class="sourceLine" id="cb18-3" data-line-number="3"><span class="dt">  real(C_DOUBLE)</span>, <span class="dt">public</span> <span class="dt">::</span> bar</a>
<a class="sourceLine" id="cb18-4" data-line-number="4"><span class="dt">end type</span></a></code></pre></div>
<p>Currently this feature must be activated using a special macro <code>%fortran_bindc_struct</code>:</p>
<pre class="swig"><code>%fortran_bindc_struct(BasicStruct);
</code></pre>
<p>In both cases, unlike many other SWIG languages, the proxy code produced by Fortran is <em>strongly typed</em>: mistakenly using the wrong type will result in a compiler error as opposed to a runtime error.</p>
<h2 id="ignored-or-unimplemented-forward-declared-structs-and-classes">Ignored or unimplemented forward-declared structs and classes</h2>
<p>Some functions may include references or pointers to classes that are not wrapped by Fortran proxy functions. In these cases, an opaque derived type called <code>SwigUnknownClass</code> will be generated and used as a placeholder for the argument or return value. These could theoretically be passed between wrapped SWIG functions, although no type checking will be performed to ensure that the unknown classes are the correct types.</p>
<h2 id="enumerations">Enumerations</h2>
<p>Fortran 2003 supports C-bound enumerations but <a href="https://www.ibm.com/support/knowledgecenter/SS2MB5_14.1.0/com.ibm.xlf141.bg.doc/language_ref/enum.html">does not allow them to be typed</a>: in effect, enumerators are simply a set of loosely grouped compile-time integer constants.</p>
<p>To associate a C enumeration name with the Fortran generated wrappers, SWIG generates an additional enumeration with the C class name and a dummy value of <code>-1</code>. The enumeration generated from the C code</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb20-1" data-line-number="1"><span class="kw">enum</span> MyEnum {</a>
<a class="sourceLine" id="cb20-2" data-line-number="2">    RED = <span class="dv">0</span>,</a>
<a class="sourceLine" id="cb20-3" data-line-number="3">    GREEN,</a>
<a class="sourceLine" id="cb20-4" data-line-number="4">    BLUE,</a>
<a class="sourceLine" id="cb20-5" data-line-number="5">    BLACK = <span class="dv">-1</span></a>
<a class="sourceLine" id="cb20-6" data-line-number="6">};</a></code></pre></div>
<p>looks like:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode fortran"><code class="sourceCode fortran"><a class="sourceLine" id="cb21-1" data-line-number="1"> enum, bind(c)</a>
<a class="sourceLine" id="cb21-2" data-line-number="2">  enumerator <span class="dt">::</span> MyEnum <span class="kw">=</span> <span class="kw">-</span><span class="dv">1</span></a>
<a class="sourceLine" id="cb21-3" data-line-number="3">  enumerator <span class="dt">::</span> RED <span class="kw">=</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb21-4" data-line-number="4">  enumerator <span class="dt">::</span> GREEN <span class="kw">=</span> RED <span class="kw">+</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb21-5" data-line-number="5">  enumerator <span class="dt">::</span> BLUE <span class="kw">=</span> GREEN <span class="kw">+</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb21-6" data-line-number="6">  enumerator <span class="dt">::</span> BLACK <span class="kw">=</span> <span class="kw">-</span><span class="dv">1</span></a>
<a class="sourceLine" id="cb21-7" data-line-number="7"> <span class="kw">end</span> enum</a></code></pre></div>
<p>These are then treated as standard C integers elsewhere in the code; on the Fortran side this is achieved with the dummy argument type <code>integer(kind(MyEnum))</code>.</p>
<p>Some C++ enumeration definitions cannot be natively interpreted by a Fortran compiler (e.g. <code>FOO = 0x12,</code> or <code>BAR = sizeof(int),</code>), so these are defined in the C++ wrapper code and <em>bound</em> in the Fortran wrapper code:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode fortran"><code class="sourceCode fortran"><a class="sourceLine" id="cb22-1" data-line-number="1"><span class="dt">integer(C_INT)</span>, protected, <span class="dt">public</span>, <span class="kw">&amp;</span></a>
<a class="sourceLine" id="cb22-2" data-line-number="2">   bind(C, name<span class="kw">=</span><span class="st">&quot;swigc_FOO&quot;</span>) <span class="dt">::</span> FOO</a></code></pre></div>
<p>The <code>%enumerator</code> and <code>%noenumerator</code> features can be used to explicitly enable and disable treatment of a C++ <code>enum</code> as a Fortran enumerator.</p>
<h2 id="function-pointers">Function pointers</h2>
<p>It is possible to pass function pointers both from C to Fortran and from Fortran to C using SWIG. Currently function pointers only work with user-created C-linkage functions as described below, but we plan to extend function callbacks so that data can be translated through wrapper functions.</p>
<p>Another planned extension for function pointers is to automatically generate the necessary <em>abstract interface</em> code required by Fortran to interpret the function pointer. Currently, function pointer variables simply generate opaque <code>type(C_FUNPTR)</code> objects.</p>
<p>Calling C functions from Fortran as pointers can be done using <a href="https://software.intel.com/en-us/node/679091">c_f_procpointer</a>:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode fortran"><code class="sourceCode fortran"><a class="sourceLine" id="cb23-1" data-line-number="1"><span class="kw">subroutine</span> CallIt(cp) bind(c)</a>
<a class="sourceLine" id="cb23-2" data-line-number="2">  <span class="kw">use</span>, <span class="kw">intrinsic</span> <span class="dt">::</span> iso_c_binding</a>
<a class="sourceLine" id="cb23-3" data-line-number="3">  <span class="dt">type(c_funptr)</span>, <span class="dt">intent(in)</span> <span class="dt">::</span> cp</a>
<a class="sourceLine" id="cb23-4" data-line-number="4">  abstract <span class="kw">interface</span></a>
<a class="sourceLine" id="cb23-5" data-line-number="5">    <span class="kw">subroutine</span> Add_Int(i) bind(c)</a>
<a class="sourceLine" id="cb23-6" data-line-number="6">      import</a>
<a class="sourceLine" id="cb23-7" data-line-number="7">      <span class="dt">integer(c_int)</span>, <span class="dt">intent(inout)</span> <span class="dt">::</span> i</a>
<a class="sourceLine" id="cb23-8" data-line-number="8">    <span class="kw">end subroutine</span> Add_Int</a>
<a class="sourceLine" id="cb23-9" data-line-number="9">  <span class="kw">end interface</span></a>
<a class="sourceLine" id="cb23-10" data-line-number="10">  <span class="kw">procedure</span>(Add_Int), <span class="dt">pointer</span> <span class="dt">::</span> fp</a>
<a class="sourceLine" id="cb23-11" data-line-number="11">  <span class="dt">integer(c_int)</span> <span class="dt">::</span> j</a>
<a class="sourceLine" id="cb23-12" data-line-number="12"></a>
<a class="sourceLine" id="cb23-13" data-line-number="13">  <span class="kw">call</span> c_f_procpointer(cp, fp)</a>
<a class="sourceLine" id="cb23-14" data-line-number="14">  j <span class="kw">=</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb23-15" data-line-number="15">  <span class="kw">call</span> fp(j)</a>
<a class="sourceLine" id="cb23-16" data-line-number="16"><span class="kw">end subroutine</span> CallIt</a></code></pre></div>
<p>See the <code>funcptr</code> example in SWIG for an example of the current callback functionality in practice.</p>
<h2 id="handles-and-other-oddities">Handles and other oddities</h2>
<p>Most combinations of pointers and references (such as <code>int**</code>, <code>int* const*</code>, <code>int*[3]</code>, <code>int*&amp;</code>) are treated as opaque C pointers. They can be passed through the Fortran/C interface but currently have no special meaning or operations in generated Fortran code.</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb24-1" data-line-number="1"><span class="dt">double</span>** get_handle();</a></code></pre></div>
<p>becomes</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode fortran"><code class="sourceCode fortran"><a class="sourceLine" id="cb25-1" data-line-number="1"><span class="kw">function</span> get_handle() <span class="kw">&amp;</span></a>
<a class="sourceLine" id="cb25-2" data-line-number="2">    <span class="kw">result</span>(swig_result)</a>
<a class="sourceLine" id="cb25-3" data-line-number="3">  <span class="kw">use</span>, <span class="kw">intrinsic</span> <span class="dt">::</span> ISO_C_BINDING</a>
<a class="sourceLine" id="cb25-4" data-line-number="4">  <span class="dt">type(C_PTR)</span> <span class="dt">::</span> swig_result</a>
<a class="sourceLine" id="cb25-5" data-line-number="5"><span class="kw">end function</span></a></code></pre></div>
<p>Similarly, member function pointers (bound to a member function of a particular class instance) are supported as opaque Fortran objects.</p>
<!-- ###################################################################### -->

<h1 id="basic-cc-features">Basic C/C++ features</h1>
<p>This section describes how C and C++ language features can generate Fortran wrapper code.</p>
<h2 id="functions">Functions</h2>
<p>Functions in C/C++ are <em>procedures</em> in Fortran. Their arguments correspond directly between the two languages: one argument in the C code requires one argument in the Fortran proxy. (An exception is that C arguments can be ignored by swig using the <code>%typemap(in, numinputs=0)</code> directive in SWIG.) A function in C/C++ with a <code>void</code> return value will construct a <code>subroutine</code> in Fortran, and a function returning anything else will yield a Fortran <code>function</code>.</p>
<p>Each function in SWIG has a unique &quot;symbolic name&quot; or <em>symname</em> bound to it. The <em>symname</em> must be compatible with C linkage, so namespaces, templates, and overloads are incorporated into the symname, but they are often just the same as the bare function name.</p>
<!--
For example, a function 
```c++
namespace foo {
template<typename T>
void bar(T arg);
}
```
and instantiated with
```swig
%template(bar_dbl) foo::bar<double>;
```
might a symbolic name `bar_dbl
-->

<p>SWIG will generate a wrapper function in the C++ file named <code>swigc_$symname</code>, where <code>$symname</code> is replaced with the symname. A corresponding private <code>BIND(C)</code> interface statement will be generated in the Fortran interface module. This wrapper function is responsible for translating the function's arguments and return value into types compatible with the Fortran/C interoperability features and calling the C++ function.</p>
<p>In the Fortran module, SWIG generates a public procedure <code>$symname</code> translates the C interface data into Fortran data types. This interface is the one used by Fortran application codes.</p>
<p>There is an important exception to the naming scheme described above: overloaded functions in C++ create private procedures suffixed with unique strings. These procedures are then combined under a <em>separate module procedure</em> that is given a public interface with the original symbolic name.</p>
<h2 id="global-variables">Global variables</h2>
<p>Global variables in SWIG are wrapped with &quot;getter&quot; and &quot;setter&quot; functions. In the case of a global C++ variable</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode c++"><code class="sourceCode cpp"><a class="sourceLine" id="cb26-1" data-line-number="1"><span class="kw">namespace</span> foo {</a>
<a class="sourceLine" id="cb26-2" data-line-number="2"><span class="at">extern</span> <span class="dt">int</span> global_counter;</a>
<a class="sourceLine" id="cb26-3" data-line-number="3">}</a></code></pre></div>
<p>SWIG will generate functions with interfaces</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode fortran"><code class="sourceCode fortran"><a class="sourceLine" id="cb27-1" data-line-number="1"><span class="kw">subroutine</span> set_global_counter(value0)</a>
<a class="sourceLine" id="cb27-2" data-line-number="2">  <span class="kw">use</span>, <span class="kw">intrinsic</span> <span class="dt">::</span> ISO_C_BINDING</a>
<a class="sourceLine" id="cb27-3" data-line-number="3">  <span class="dt">integer(C_INT)</span>, <span class="dt">intent(in)</span> <span class="dt">::</span> value0</a>
<a class="sourceLine" id="cb27-4" data-line-number="4"><span class="kw">end subroutine</span></a></code></pre></div>
<p>and</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode fortran"><code class="sourceCode fortran"><a class="sourceLine" id="cb28-1" data-line-number="1"><span class="kw">function</span> get_global_counter() <span class="kw">&amp;</span></a>
<a class="sourceLine" id="cb28-2" data-line-number="2">  <span class="kw">result</span>(swigf_result)</a>
<a class="sourceLine" id="cb28-3" data-line-number="3">  <span class="kw">use</span>, <span class="kw">intrinsic</span> <span class="dt">::</span> ISO_C_BINDING</a>
<a class="sourceLine" id="cb28-4" data-line-number="4">  <span class="dt">integer(C_INT)</span> <span class="dt">::</span> swigf_result</a>
<a class="sourceLine" id="cb28-5" data-line-number="5"><span class="kw">end function</span></a></code></pre></div>
<p>Although no type conversion is needed for simple integers, other global data types would require special wrapper code in these functions.</p>
<p>Currently, global C/Fortran-compatible variables are treated the same as C++ data, but in the future we plan to expand the <code>%bindc</code> feature to directly wrap</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode c++"><code class="sourceCode cpp"><a class="sourceLine" id="cb29-1" data-line-number="1"><span class="at">extern</span> <span class="st">&quot;C&quot;</span> {</a>
<a class="sourceLine" id="cb29-2" data-line-number="2"><span class="at">extern</span> <span class="dt">int</span> global_counter_c;</a>
<a class="sourceLine" id="cb29-3" data-line-number="3">}</a></code></pre></div>
<p>as a C-bound common block variable bound</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode fortran"><code class="sourceCode fortran"><a class="sourceLine" id="cb30-1" data-line-number="1"><span class="dt">integer(C_INT)</span>, bind(C, name<span class="kw">=</span><span class="st">&quot;global_counter_c&quot;</span>) <span class="dt">::</span> global_counter_c</a></code></pre></div>
<h3 id="global-constants">Global constants</h3>
<p>Global constant variables (whether declared in C++ headers with <code>const</code> or in a SWIG wrapper with <code>%constant</code>) of native types can be wrapped as Fortran parameters:</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode c++"><code class="sourceCode cpp"><a class="sourceLine" id="cb31-1" data-line-number="1">%parameter approx_pi;</a>
<a class="sourceLine" id="cb31-2" data-line-number="2"><span class="at">const</span> <span class="dt">double</span> approx_pi = <span class="fl">3.1416</span>;</a></code></pre></div>
<p>will be translated to</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode fortran"><code class="sourceCode fortran"><a class="sourceLine" id="cb32-1" data-line-number="1"><span class="dt"> real(C_DOUBLE)</span>, <span class="dt">parameter</span>, <span class="dt">public</span> <span class="dt">::</span> approx_pi <span class="kw">=</span> <span class="fl">3.1416_C_DOUBLE</span></a></code></pre></div>
<p>If the variable is defined in the header file and is a simple integer, this feature will be enabled by default. It can be explicitly enabled or disabled using the <code>%parameter</code> and <code>%noparameter</code> directives.</p>
<h2 id="classes">Classes</h2>
<p>As mentioned previously, C++ classes are transformed to Fortran <em>derived types</em>. These types have <em>type-bound procedures</em> that mirror the C++ <em>member functions</em>. Other SWIG target languages refer to the transformed wrapper classes as &quot;proxy classes&quot; because they act as a proxy to the underlying C++ class.</p>
<p>The derived type in Fortran is effectively a C pointer with memory management metadata. The C pointer is initialized to <code>C_NULL_PTR</code>, and when assigned it can represent a class as a <em>value</em> (i.e. the local Fortran code has ownership) or by <em>reference</em>. More details about <a href="#memory-management">memory management of classes</a>, are available in the section that details the proxy classes that SWIG constructs.</p>
<h3 id="constructors-and-destructors">Constructors and Destructors</h3>
<p>Because Fortran is not a stack-based language like C (where variables enter and leave scope by being pushed onto and popped off the memory stack), generally speaking the storage duration of <em>all</em> data (functions, arrays) is static, where their location in memory is determined at compile/link time. And, unlike C++, there is no static initialization of objects.</p>
<p>Consequently, the concept of &quot;scope&quot; for an object does not translate directly to Fortran, and construction/destruction is performed manually. Because of limitations in <a href="#function-overloading">function overloading</a> with <a href="#inheritance">inheritance</a>, it is not generally possible to provide a type-bound procedure that mirrors the C++ constructors. The design decision was made to treat construction through procedures <em>not</em> bound to a type. The constructor is wrapped as <code>create_{symname}</code>:</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode fortran"><code class="sourceCode fortran"><a class="sourceLine" id="cb33-1" data-line-number="1"><span class="dt">type(Foo)</span> <span class="dt">::</span> f</a>
<a class="sourceLine" id="cb33-2" data-line-number="2"><span class="dt">type(Foo)</span> <span class="dt">::</span> g</a>
<a class="sourceLine" id="cb33-3" data-line-number="3">f <span class="kw">=</span> create_Foo()</a>
<a class="sourceLine" id="cb33-4" data-line-number="4">g <span class="kw">=</span> create_Foo(<span class="dv">123</span>)</a></code></pre></div>
<p>Freeing memory and cleaning up the associated C++ class is done by calling the <code>release</code> procedure on the Fortran object.</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode fortran"><code class="sourceCode fortran"><a class="sourceLine" id="cb34-1" data-line-number="1"><span class="kw">call</span> f%release()</a>
<a class="sourceLine" id="cb34-2" data-line-number="2"><span class="kw">call</span> g%release()</a></code></pre></div>
<p>To be safe, <code>release</code> should always be called when the proxy instance is no longer needed. It will free memory if appropriate and reset the C pointer to <code>NULL</code>.</p>
<h3 id="member-functions">Member functions</h3>
<p>SWIG generates unique, private procedure names for each class and function. These procedures are bound to the type. If <a href="#function-overloading">function overloading</a> is used, &quot;generic&quot; procedures will be added to the derived type.</p>
<p>Type-bound procedures in Fortran can be used as follows:</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode fortran"><code class="sourceCode fortran"><a class="sourceLine" id="cb35-1" data-line-number="1"><span class="dt">integer(C_INT)</span> <span class="dt">::</span> value</a>
<a class="sourceLine" id="cb35-2" data-line-number="2"><span class="dt">type(Foo)</span> <span class="dt">::</span> food</a>
<a class="sourceLine" id="cb35-3" data-line-number="3">food <span class="kw">=</span> create_Foo()</a>
<a class="sourceLine" id="cb35-4" data-line-number="4"><span class="kw">call</span> food%do_something()</a>
<a class="sourceLine" id="cb35-5" data-line-number="5">value <span class="kw">=</span> food%get_something()</a></code></pre></div>
<h3 id="member-data">Member data</h3>
<p>Just like <a href="#global-variables">global variables</a>, SWIG generates member functions for getters and, when appropriate, setters.</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode fortran"><code class="sourceCode fortran"><a class="sourceLine" id="cb36-1" data-line-number="1"><span class="dt">type(Foo)</span> <span class="dt">::</span> f</a>
<a class="sourceLine" id="cb36-2" data-line-number="2">f <span class="kw">=</span> create_Foo()</a>
<a class="sourceLine" id="cb36-3" data-line-number="3"><span class="kw">call</span> food%set_val(<span class="dv">123</span>)</a>
<a class="sourceLine" id="cb36-4" data-line-number="4">value <span class="kw">=</span> food%get_something()</a></code></pre></div>
<h3 id="inheritance">Inheritance</h3>
<p>Single inheritance in C++ is mirrored by Fortran using the <code>EXTENDS</code> attribute. For classes with virtual methods, the user should keep in mind that function calls are dispatched through C++. In other words, even if you call a base-class member function in Fortran that wraps a derived class instance, the correct virtual function call will be dispatched.</p>
<p>Fortran has no mechanism for multiple inheritance, so this SWIG target language does not support it. The first base class listed that has not been <code>%ignore</code>d will be treated as the single parent class.</p>
<p>There is no intrinsic way to <code>dynamic_cast</code> to a daughter class, but if a particular casting operation is needed a small inline function can be created that should suffice:</p>
<pre class="swig"><code>%inline %{
Derived&amp; base_to_derived(Base&amp; b) {
    return dynamic_cast&lt;Derived&amp;&gt;(b);
}
%}
</code></pre>
<p>(Note that this function will <em>not</em> transfer ownership to the new object. Doing that is outside the scope of this chapter.)</p>
<h2 id="exceptions">Exceptions</h2>
<p>By default, a C++ exception will call <code>std::terminate</code> to be called, abruptly aborting the Fortran program execution. With the <code>%exception</code> feature, C++ exceptions can be caught and handled by the Fortran code by setting and clearing an integer flag. The following snippet from the Examples directory illustrates it default use:</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode fortran"><code class="sourceCode fortran"><a class="sourceLine" id="cb38-1" data-line-number="1"><span class="kw">use</span> except, <span class="kw">only</span> : do_it, ierr, get_serr</a>
<a class="sourceLine" id="cb38-2" data-line-number="2"><span class="kw">call</span> do_it(<span class="kw">-</span><span class="dv">3</span>)</a>
<a class="sourceLine" id="cb38-3" data-line-number="3"><span class="kw">if</span> (ierr <span class="op">/=</span> <span class="dv">0</span>) <span class="kw">then</span></a>
<a class="sourceLine" id="cb38-4" data-line-number="4">  <span class="fu">write(</span><span class="dv">0</span>,<span class="fu">*)</span> <span class="st">&quot;Got error &quot;</span>, ierr, <span class="st">&quot;: &quot;</span>, get_serr()</a>
<a class="sourceLine" id="cb38-5" data-line-number="5">  ierr <span class="kw">=</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb38-6" data-line-number="6"><span class="kw">endif</span></a></code></pre></div>
<p>Enabling the</p>
<pre class="swig"><code>%include &lt;std_except.i&gt;

%exception {
  // Make sure no unhandled exceptions exist before performing a new action
  SWIG_check_unhandled_exception();
  try {
    // Attempt the wrapped function call
    $action
  } catch (std::exception&amp; e) {
    SWIG_exception(SWIG_RuntimeError, e.what() );
  } catch (...) {
    SWIG_exception(SWIG_UnknownError, &quot;An unknown exception occurred&quot;);
  }
}

%inline %{
#include &lt;stdexcept&gt;
void do_it(int i)
{
  if (i &lt; 0) throw std::runtime_error(&quot;Bad value&quot;);
}
%}
</code></pre>
<p>The above code will wrap (by default) <em>every</em> function call. (The standard SWIG <code>%allowexception</code> and <code>%noallowexception</code> directives can be used to selectively enable or disable exception handling). Before calling the wrapped function, the call to <code>SWIG_check_unhandled_exception</code> ensures that no previous unhandled error</p>
<p>The names of the integer and string accessor will have C linkage and thus must be unique in a compiled program. Since other translation units might have symbols that share the default exception handling names, the user can provide custom names before including the exception handling file:</p>
<pre class="swig"><code>#define SWIG_FORTRAN_ERROR_INT my_ierr
#define SWIG_FORTRAN_ERROR_STR get_my_serr
%include &lt;std_except.i&gt;
</code></pre>
<h2 id="shared-pointers">Shared pointers</h2>
<!-- ###################################################################### -->

<h1 id="typemaps">Typemaps</h1>
<p>SWIG Fortran extends the typemap system of SWIG with additional typemaps. There are two new typemaps to declare the data types used by Fortran and C in the intermediate layer, and two typemaps for translating the intermediate layer types to the final Fortran types.</p>
<p>To pass Fortran-2003 compatible <code>BIND(&quot;C&quot;)</code> or <code>ISO_C_BINDING</code> types between C++ and Fortran, you must declare a compatible <code>ctype</code> and <code>ftype</code>. The <code>ctype</code> is the C datatype used by the wrapper and intermediate layer, and <code>ftype</code> is the equivalent Fortran datatype. These datatypes generally must be either fundamental types or structs of fundamental types. For example, as described in <code>Fundamental types</code> section, the <code>int</code> C type corresponds to the <code>integer(C_INT)</code> Fortran type.</p>
<p>Note that fundamental types include the opaque pointer <code>void*</code> and its Fortran equivalent <code>type(C_PTR)</code> as well as function pointers and the opaque Fortran equivalent <code>type(C_FUNPTR)</code>.</p>
<h2 id="fortran-proxy-datatype-translation">Fortran proxy datatype translation</h2>
<p>The <code>fin</code> and <code>fout</code> typemaps are Fortran proxy wrapper code analogous to the <code>in</code> and <code>out</code> in the C wrapper code: they are used for translating native Fortran objects and types into types that can be transmitted through the C layer. For example, to pass a class by reference, the Fortran class <code>class(SimpleClass) :: self</code> is converted to the corresponding C class via the stored C pointer using the <code>fin</code> typemap, which is expanded to:</p>
<div class="sourceCode" id="cb41"><pre class="sourceCode fortran"><code class="sourceCode fortran"><a class="sourceLine" id="cb41-1" data-line-number="1">farg1 <span class="kw">=</span> self%swigdata%ptr</a></code></pre></div>
<p>This argument is then passed into the C function call:</p>
<div class="sourceCode" id="cb42"><pre class="sourceCode fortran"><code class="sourceCode fortran"><a class="sourceLine" id="cb42-1" data-line-number="1">fresult <span class="kw">=</span> swigc_make_class(farg1)</a></code></pre></div>
<p>and the output is translated back via the <code>fout</code> typemap, which in this case expands to:</p>
<div class="sourceCode" id="cb43"><pre class="sourceCode fortran"><code class="sourceCode fortran"><a class="sourceLine" id="cb43-1" data-line-number="1">swig_result%swigdata%ptr <span class="kw">=</span> fresult</a></code></pre></div>
<h2 id="special-overrides-for-return-variables">Special overrides for return variables</h2>
<p>Sometimes a return type in C++ needs additional contextual information to be meaningful in Fortran. For example, a returned pointer may be the first element in a C array but requires a size to be used as an array. Since special typemaps cannot be applied to output variables like they can for inputs (i.e. <code>%typemap(in) int* OUTPUT</code>), we provide a <code>%feature</code> directive for additional customization.</p>
<p>Consider a vector-like C++ class:</p>
<div class="sourceCode" id="cb44"><pre class="sourceCode c++"><code class="sourceCode cpp"><a class="sourceLine" id="cb44-1" data-line-number="1"><span class="kw">class</span> Array {</a>
<a class="sourceLine" id="cb44-2" data-line-number="2"><span class="kw">public</span>:</a>
<a class="sourceLine" id="cb44-3" data-line-number="3">  <span class="dt">double</span>* data();</a>
<a class="sourceLine" id="cb44-4" data-line-number="4">  <span class="dt">int</span> size();</a>
<a class="sourceLine" id="cb44-5" data-line-number="5">};</a></code></pre></div>
<p>With typemaps alone, it's impossible to convert the return value from <code>data</code> to a sized array pointer in Fortran. (By default, <code>data</code> is interpreted as a scalar pointer.) Since the SWIG <code>%feature</code> directive can be applied to specific functions and methods, we can use <code>%feature(&quot;ftype&quot;)</code> and <code>%feature(&quot;fout&quot;)</code> to override the <code>%typemap(&quot;ftype&quot;) double*</code> and <code>%typemap(&quot;fout&quot;) double*</code>:</p>
<pre class="swig"><code>%feature(&quot;ftype&quot;) Array::data %{
real(C_DOUBLE), dimension(:), pointer
%}
%feature(&quot;fout&quot;) Array::data %{
call c_f_pointer($1, $result, [self%size()])
%}
</code></pre>
<h2 id="allocating-local-fortran-variables-in-wrapper-codes">Allocating local Fortran variables in wrapper codes</h2>
<p>Advanced SWIG users may know that</p>
<pre class="swig"><code>%typemap(in) int (double tempval) { /.../ }
</code></pre>
<p>is a way to declare a temporary variable <code>tempval</code> in the C wrapper code. The same feature is emulated in the special typemaps <code>findecl</code> and <code>foutdecl</code>, which are inserted into the variable declaration blocks when the corresponding types are used. If <code>findecl</code> allocates a temporary variable, the <code>ffrearg</code> typemap (analogous to the <code>freearg</code> typemap for C <code>in</code> arguments) can be used to deallocate it.</p>
<p>An example for returning a native <code>allocatable</code> Fortran string from a C++ string reference must declare a temporary array pointer to the C data, then copy the result into a Fortran string.</p>
<pre class="swig"><code>%typemap(ftype, out=&quot;character(kind=C_CHAR, len=:), allocatable&quot;)
    const std::string&amp;
&quot;character(kind=C_CHAR, len=*), target&quot;

// Fortran proxy translation code: temporary variables for output
%typemap(foutdecl) const std::string&amp;
%{
 integer(kind=C_SIZE_T) :: $1_i
 character(kind=C_CHAR), dimension(:), pointer :: $1_chars
%}

// Fortran proxy translation code: convert from imtype $1 to ftype $result
%typemap(fout) const std::string&amp;
%{
  call c_f_pointer($1%data, $1_chars, [$1%size])
  allocate(character(kind=C_CHAR, len=$1%size) :: $result)
  do $1_i=1,$1%size
    $result($1_i:$1_i) = $1_chars($1_i)
  enddo
%}
</code></pre>
<h2 id="special-class-typemaps">Special class typemaps</h2>
<p>To facility the wrapping and customizability of C++ classes, there are a few additional special typemaps that only apply to classes. They generally should not need to be modified.</p>
<p>The <code>fdata</code> typemap declares the data object that is stored by the Fortran proxy class. Note that only the base class of any inheritance hierarchy contains this data.</p>
<p>The <code>fdestructor</code> typemap becomes the Fortran wrapper code for the <code>release</code> type-bound procedure. The special token <code>$action</code> is replaced by the call to the C wrapper for the destructor. Currently, all classes have the same destructor action but this may change. (TODO: should this be a <code>%feature</code>? Or should <code>%feature(&quot;unref&quot;)</code> be a typemap?)</p>
<h2 id="fortran-interoperability">Fortran interoperability</h2>
<p>There are a few ways to make C++ code interact more cleanly with Fortran. For example, many interfaces take a <code>std::string</code>, but it would be <em>really</em> convenient not to have to instantiate a string class for each argument. To this end, a special typemap is provided that transparently converts native Fortran character strings to and from <code>std::string</code> classes.</p>
<p>To use it globally and prevent the <code>std::string</code> wrapper class from being instantiated, do the following:</p>
<pre class="swig"><code>%ignore std::string;
%include &lt;std_string.i&gt;
%apply const std::string&amp; NATIVE { const std::string&amp; };
</code></pre>
<p>You can of course selectively <code>%apply</code> that typemap like any other SWIG typemap. To apply it only to the output of a particular class <code>const std::string&amp; get_foo()</code>, you can use</p>
<pre class="swig"><code>%apply const std::string&amp; NATIVE { const std::string&amp; get_foo };
</code></pre>
<p>Similarly, instantiating a <code>std::vector</code> creates a typemap that allows native treatment of array inputs and outputs. This is used in the ForTrilinos to treat <code>ParameterList</code> embedded arrays as native Fortran arrays for convenience.</p>
<p>One other note to be made about Fortran interoperability concerns the mismatch between default Fortran integers and C++'s <code>size_type</code>, which is often used as a parameter. The mismatch requires that users awkwardly cast values when passing into function calls:</p>
<div class="sourceCode" id="cb50"><pre class="sourceCode fortran"><code class="sourceCode fortran"><a class="sourceLine" id="cb50-1" data-line-number="1"><span class="kw">call</span> my_vector%resize(<span class="bu">INT</span>(n,C_LONG))</a></code></pre></div>
<p>This nuisance can be simply avoided by replacing occurrences of C's size type with the native Fortran integer type:</p>
<pre class="swig"><code>%apply int { std::size_t }
</code></pre>
<!-- ###################################################################### -->

<h1 id="direct-c-binding">Direct C binding</h1>
<h2 id="generating-c-bound-fortran-types-from-c-structs">Generating C-bound Fortran types from C structs</h2>
<p>The Fortran SWIG module provides a macro <code>%fortran_bindc_struct</code> that creates a native Fortran <code>TYPE</code> for simple C structs. In C++, these structs must be &quot;standard layout&quot;, i.e. compatible with C. (Roughly speaking, there must be no virtual member functions, inheritance, or C++-like member data.)</p>
<p>Calling <code>%fortran_bindc_struct(Foo)</code> inhibits default constructor/destructor generation for the class, and it sets up the necessary type definitions to treat the struct as a fundamental type.</p>
<p>Every member of the struct must be <code>BIND(C)</code> compatible. This is enforced with a separate typemap <code>bindc</code> that translates the member data to Fortran type members. For example, the basic <code>int</code> mappings are defined (using macros) as:</p>
<pre class="swig"><code>%typemap(bindc) int      &quot;integer(C_INT)&quot;
%typemap(bindc) int*     &quot;type(C_PTR)&quot;
%typemap(bindc) int[ANY] &quot;integer(C_INT), dimension($1_dim0)&quot;
%typemap(bindc) int[] = int*;
</code></pre>
<p>The <code>bindc</code> typemap is used when wrapping global constants as well.</p>
<h2 id="interfaces-with-fortran-c-bound-types">Interfaces with Fortran C-bound types</h2>
<p>If types defined in the SWIG Fortran module are to be used as part of the interface (as is the case with structs), it is necessary to &quot;import&quot; the type into the interface to use it. This is accomplished by the <code>import</code> keyword argument to the <code>imtype</code> typemap. For example, whenever the following typemap is used in the intermediate wrapper:</p>
<pre class="swig"><code>%typemap(imtype, import=&quot;SwigfArrayWrapper&quot;)  FooArray
  &quot;type(SwigfArrayWrapper)&quot;;
</code></pre>
<p>an <code>import</code> directive will be inserted into the Fortran proxy function:</p>
<div class="sourceCode" id="cb54"><pre class="sourceCode fortran"><code class="sourceCode fortran"><a class="sourceLine" id="cb54-1" data-line-number="1"><span class="kw">module</span> thinvec</a>
<a class="sourceLine" id="cb54-2" data-line-number="2"> <span class="kw">use</span>, <span class="kw">intrinsic</span> <span class="dt">::</span> ISO_C_BINDING</a>
<a class="sourceLine" id="cb54-3" data-line-number="3"> <span class="kw">implicit</span> <span class="kw">none</span></a>
<a class="sourceLine" id="cb54-4" data-line-number="4"></a>
<a class="sourceLine" id="cb54-5" data-line-number="5"> <span class="dt">type</span>, <span class="dt">public</span>, bind(C) <span class="dt">::</span> SwigfArrayWrapper</a>
<a class="sourceLine" id="cb54-6" data-line-number="6">   <span class="dt">type(C_PTR)</span>, <span class="dt">public</span> <span class="dt">::</span> data</a>
<a class="sourceLine" id="cb54-7" data-line-number="7">   <span class="dt">integer(C_SIZE_T)</span>, <span class="dt">public</span> <span class="dt">::</span> <span class="fu">size</span></a>
<a class="sourceLine" id="cb54-8" data-line-number="8"> <span class="dt">end type</span></a>
<a class="sourceLine" id="cb54-9" data-line-number="9"> <span class="kw">interface</span></a>
<a class="sourceLine" id="cb54-10" data-line-number="10"> <span class="kw">subroutine</span> swigc_foo(farg1) <span class="kw">&amp;</span></a>
<a class="sourceLine" id="cb54-11" data-line-number="11">   bind(C, name<span class="kw">=</span><span class="st">&quot;swigc_foo&quot;</span>)</a>
<a class="sourceLine" id="cb54-12" data-line-number="12">   <span class="kw">use</span>, <span class="kw">intrinsic</span> <span class="dt">::</span> ISO_C_BINDING</a>
<a class="sourceLine" id="cb54-13" data-line-number="13">   import <span class="dt">::</span> SwigfArrayWrapper    <span class="co">! Will not compile without this line</span></a>
<a class="sourceLine" id="cb54-14" data-line-number="14">   <span class="dt">type(SwigfArrayWrapper)</span> <span class="dt">::</span> farg1</a>
<a class="sourceLine" id="cb54-15" data-line-number="15"> <span class="kw">end subroutine</span></a></code></pre></div>
<p>This extra typemap trickery should only be needed if you're generating bound types without using the <code>%fortran_bindc_struct</code> macro.</p>
<h2 id="generating-direct-fortran-interfaces-to-c-functions">Generating direct Fortran interfaces to C functions</h2>
<p>In addition to generating functions with translation code, it is also possible to specify that a function be directly <em>bound</em> and not <em>wrapped</em>. For this feature to work correctly, all function arguments and return types must be inherently Fortran/C interoperable. If using C++, the function must be defined using <code>extern &quot;C&quot;</code> linkage; and in fact, when SWIG is asked to wrap a function with that linkage, it defaults to binding it. Use the <code>%nobindc my_func_name;</code> feature to suppress this behavior.</p>
<p>The C++ code:</p>
<div class="sourceCode" id="cb55"><pre class="sourceCode C++"><code class="sourceCode cpp"><a class="sourceLine" id="cb55-1" data-line-number="1"><span class="at">extern</span> <span class="st">&quot;C&quot;</span> {</a>
<a class="sourceLine" id="cb55-2" data-line-number="2"><span class="co">// These functions are simply bound, not wrapped.</span></a>
<a class="sourceLine" id="cb55-3" data-line-number="3"><span class="dt">void</span> print_sphere(<span class="at">const</span> <span class="dt">double</span> origin[<span class="dv">3</span>], <span class="at">const</span> <span class="dt">double</span>* radius);</a>
<a class="sourceLine" id="cb55-4" data-line-number="4">}</a></code></pre></div>
<p>is automatically translated into</p>
<div class="sourceCode" id="cb56"><pre class="sourceCode fortran"><code class="sourceCode fortran"><a class="sourceLine" id="cb56-1" data-line-number="1"><span class="kw">subroutine</span> print_sphere(origin, radius) <span class="kw">&amp;</span></a>
<a class="sourceLine" id="cb56-2" data-line-number="2">    bind(C, name<span class="kw">=</span><span class="st">&quot;print_sphere&quot;</span>)</a>
<a class="sourceLine" id="cb56-3" data-line-number="3">  <span class="kw">use</span>, <span class="kw">intrinsic</span> <span class="dt">::</span> ISO_C_BINDING</a>
<a class="sourceLine" id="cb56-4" data-line-number="4"><span class="dt">  real(C_DOUBLE)</span>, <span class="dt">dimension(3)</span>, <span class="dt">intent(in)</span> <span class="dt">::</span> origin</a>
<a class="sourceLine" id="cb56-5" data-line-number="5"><span class="dt">  real(C_DOUBLE)</span>, <span class="dt">intent(in)</span> <span class="dt">::</span> radius</a>
<a class="sourceLine" id="cb56-6" data-line-number="6"><span class="kw">end subroutine</span></a></code></pre></div>
<!-- ###################################################################### -->

<h1 id="swig-generated-fortran-derived-types">SWIG-generated Fortran derived types</h1>
<p>Each C++ class (excepting types wrapped as <code>BIND(C)</code> structs) creates a &quot;proxy&quot; class in the Fortran module: it is a thin wrapper that binds a C++ pointer to the corresponding SWIG-wrapped C++ methods. These classes are <em>strongly typed</em>: the compiler enforces type checking instead of runtime type checking being performed (which is the case with many other SWIG-wrapped languages).</p>
<p>Memory management in Fortran is vastly different from C and C++: it is designed for much simpler computers of the past where every subroutine and variable in the computer memory had a specific address. Effectively, all data in Fortran (with the exception of functions declared <code>RECURSIVE</code>) is static: it will be initialized once and will persist between leaving and reentering a subroutine.</p>
<p>This presents significant difficulties when working with C++ classes, which often are predicated on having limited scope so that their destructor is called to release resources. We have implemented a partial workaround that tracks memory ownership inside Fortran and C++; as a bonus it enables const correctness.</p>
<p>Every proxy class holds a single piece of data, a small C-bound struct named <code>SwigfClassWrapper</code>, which contains two simple members: a pointer to C-owned memory, and an enumeration that tracks the ownership of that memory.</p>
<h2 id="memory-management">Memory management</h2>
<p>For reasons of simplicity, a single Fortran proxy class must be able to act as a value, a pointer, or a reference. They must be able to be created and destroyed without double-deleting memory. Finally, and most frustratingly, C++ functions must be able to return both new'd data and referenced data to Fortran, and assignment between Fortran classes must preserve memory association.</p>
<p>[ Footnote: Fortran pointers cannot be used for returning references and C pointers, because the pointed-to object needs to be a <em>proxy</em> class rather than a C++ class. ]</p>
<p>The complicating issue with assignment is that Fortran's &quot;dummy argument&quot; for the return result is <code>intent(out)</code>, preventing its previous contents (if any) from being modified or deallocated. At the same time, the assignment operator must behave correctly in both of these assignments, which are treated identically:</p>
<div class="sourceCode" id="cb57"><pre class="sourceCode fortran"><code class="sourceCode fortran"><a class="sourceLine" id="cb57-1" data-line-number="1"> <span class="dt">type(Foo)</span> <span class="dt">::</span> a, b</a>
<a class="sourceLine" id="cb57-2" data-line-number="2"> a <span class="kw">=</span> make_foo()</a>
<a class="sourceLine" id="cb57-3" data-line-number="3"> b <span class="kw">=</span> a</a></code></pre></div>
<p>Note that unlike Python, <code>b</code> is not a pointer to <code>a</code>; and unlike C++, <code>b</code> is not copy-constructed from <code>a</code>. Instead, <code>a</code> is assigned to <code>b</code> using the <code>assignment(=)</code> operator. Likewise, <code>a</code> is not &quot;constructed&quot; on the second line: there is no return value optimization as in C++. Instead, <code>make_foo</code> returns a temporary <code>Foo</code>, and that temporary is assigned to <code>a</code>.</p>
<p>Because these two assignments are treated equally and a temporary is created in only one of them, we have to be clever to avoid leaking or double-deleting memory.</p>
<p>Ideally, as was done in Rousson's implementation of Fortran shared pointers, we could rely on the <code>FINAL</code> operator defined by Fortran 2003 to release the temporary's memory. Unfortunately, even 15 years after the standard was ratified, support for <code>FINAL</code> is patchy and unreliable.</p>
<p>Our solution to this limitation is to have the <code>Foo</code> proxy class store not only a pointer to the C data but also a state enumeration <code>self%swigdata%mem</code> that describes memory ownership. The enumeration needs to have at least three options:</p>
<ul>
<li>The memory is <em>owned</em> by the proxy class (and must be deleted when calling <code>release()</code>);</li>
<li>The proxy class is a <em>reference</em> to memory owned by C/C++ (returned by either a raw pointer or a reference);</li>
<li>The memory is being allocated and returned from a function, but it must be captured by the left hand side.</li>
</ul>
<p>This last option is roughly analogous to the behavior of the deprecated <code>std::auto_ptr</code>, which was the predecessor to C++11's <code>move</code> semantics. Besides the above flags, we also define an &quot;uninitialized&quot; state for convenience, and a &quot;const reference&quot; state to enable const correctness. These flags are set by the SWIG <code>out</code> typemaps in the C wrapper code: if memory is being allocated, the return flag is <code>MOVE</code>; if a pointer is being returned, <code>REF</code> (or <code>CREF</code> in the const case) is used.</p>
<p>The final trick is to implement an assignment operator that correctly copies, allocates, or moves memory based on the flags on the left- and right-hand sides, and sets a new memory state on the recipient. By resetting the state flag in a generic assignment operator, we guarantee that <em>only</em> temporary classes will ever have the <code>MOVE</code> state.</p>
<p>For the operation <code>self = other</code>, where <code>other</code> may be a return value from a function or another class, the following actions are taken. (In the example, both classes are of type <code>This</code>, and <code>pself</code> and <code>pother</code> are the pointers being managed.)</p>
<table>
<thead>
<tr class="header">
<th>Self</th>
<th>Other</th>
<th><em>Action</em></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>NULL</td>
<td>NULL</td>
<td>(none)</td>
</tr>
<tr class="even">
<td>NULL</td>
<td>MOVE</td>
<td><code>pself = pother;</code></td>
</tr>
<tr class="odd">
<td>NULL</td>
<td>OWN</td>
<td><code>pself = new This(pother);</code></td>
</tr>
<tr class="even">
<td>NULL</td>
<td>REF/CREF</td>
<td><code>pself = pother;</code></td>
</tr>
<tr class="odd">
<td>OWN</td>
<td>NULL</td>
<td><code>delete pself; pself = NULL;</code></td>
</tr>
<tr class="even">
<td>OWN</td>
<td>MOVE</td>
<td><code>*pself = move(*pother); delete pother;</code></td>
</tr>
<tr class="odd">
<td>OWN</td>
<td>OWN</td>
<td><code>*pself = *pother;</code></td>
</tr>
<tr class="even">
<td>OWN</td>
<td>REF/CREF</td>
<td><code>*pself = *pother;</code></td>
</tr>
<tr class="odd">
<td>REF</td>
<td>NULL</td>
<td><code>pself = NULL</code></td>
</tr>
<tr class="even">
<td>REF</td>
<td>MOVE</td>
<td><code>*pself = move(*pother); delete pother;</code></td>
</tr>
<tr class="odd">
<td>REF</td>
<td>OWN</td>
<td><code>*pself = *pother;</code></td>
</tr>
<tr class="even">
<td>REF</td>
<td>REF/CREF</td>
<td><code>*pself = *pother;</code></td>
</tr>
<tr class="odd">
<td>CREF</td>
<td>NULL</td>
<td><code>pself = NULL</code></td>
</tr>
<tr class="even">
<td>CREF</td>
<td>MOVE</td>
<td>(error)</td>
</tr>
<tr class="odd">
<td>CREF</td>
<td>OWN</td>
<td>(error)</td>
</tr>
<tr class="even">
<td>CREF</td>
<td>REF/CREF</td>
<td>(error)</td>
</tr>
</tbody>
</table>
<p>The above operations are designed to preserve C++ semantics: if an proxy object owning memory is assigned, then any existing objects pointing to that memory will reflect the newly assigned value.</p>
<p>The fact that some classes disallow combinations of copy/move constructors and assignment complicates the task of evaluating the above actions. SWIG's built-in parsing of class features is usually sufficient to determine when a class can be copy-assigned or copy-constructed. If C++11 is enabled, standard library type traits override the SWIG-parsed features and additionally enable move construction and move assignment.</p>
<p>Memory can still be leaked, of course, by calling <code>make_foo()</code> without capturing and releasing the result, or by failing to call <code>release</code> on a proxy class.</p>
<h2 id="function-overloading">Function overloading</h2>
<p>Function overloading is when two or more free functions share a name but have different arguments. This is implemented using <em>generic interfaces</em>. Each overloaded function gets a unique symbolic internal name, and they are bound together. For an overloaded free function <code>myfunc</code> in C++, SWIG will generate two private procedures and add an interface to the module specification:</p>
<div class="sourceCode" id="cb58"><pre class="sourceCode fortran"><code class="sourceCode fortran"><a class="sourceLine" id="cb58-1" data-line-number="1"> <span class="dt">public</span> <span class="dt">::</span> myfunc</a>
<a class="sourceLine" id="cb58-2" data-line-number="2"> <span class="kw">interface</span> myfunc</a>
<a class="sourceLine" id="cb58-3" data-line-number="3">  <span class="kw">module procedure</span> myfunc__SWIG_<span class="dv">0</span>, myfunc__SWIG_<span class="dv">1</span></a>
<a class="sourceLine" id="cb58-4" data-line-number="4"> <span class="kw">end interface</span></a></code></pre></div>
<p>If a member function <code>doit</code> of class <code>Action</code> is overloaded, a generic binding will be generated inside the Fortran proxy derived type:</p>
<div class="sourceCode" id="cb59"><pre class="sourceCode fortran"><code class="sourceCode fortran"><a class="sourceLine" id="cb59-1" data-line-number="1">  <span class="kw">procedure</span>, <span class="dt">private</span> <span class="dt">::</span> doit__SWIG_<span class="dv">0</span> <span class="kw">=</span><span class="op">&gt;</span> swigf_Action_doit__SWIG_<span class="dv">0</span></a>
<a class="sourceLine" id="cb59-2" data-line-number="2">  <span class="kw">procedure</span>, <span class="dt">private</span> <span class="dt">::</span> doit__SWIG_<span class="dv">1</span> <span class="kw">=</span><span class="op">&gt;</span> swigf_Action_doit__SWIG_<span class="dv">1</span></a>
<a class="sourceLine" id="cb59-3" data-line-number="3">  generic <span class="dt">::</span> doit <span class="kw">=</span><span class="op">&gt;</span> doit__SWIG_<span class="dv">0</span>, doit__SWIG_<span class="dv">1</span></a></code></pre></div>
<p>It should be noted that a function that returns <code>void</code> cannot be overloaded with a function that returns anything else: generic interfaces must be either all subroutines or all functions. Use SWIG's <code>%ignore</code> statement to hide one or the other:</p>
<pre class="swig"><code>void cannot_overload(int x);
int  cannot_overload(int x, int y);
%ignore cannot_overload(int x);
</code></pre>
<h2 id="opaque-class-types">Opaque class types</h2>
<p>SWIG's default Fortran type (the <code>ftype</code> typemap) for generic types such as classes (<code>SWIGTYPE</code>) is:</p>
<pre class="swig"><code>%typemap(ftype) SWIGTYPE &quot;type($fclassname)&quot;
</code></pre>
<p>The special symbol <code>$fclassname</code> is replaced by the symbolic name of the class that matches the typemap. For example, if <code>std::vector&lt;double&gt;</code> is instantiated:</p>
<pre class="swig"><code>%template(Vec_Dbl) std::vector&lt;double&gt;;
</code></pre>
<p>then <code>Vec_Dbl</code>, the name of the derived type, will replace <code>$fclassname</code>.</p>
<p>If a class has <em>not</em> been wrapped but is encountered (e.g. in a function argument or return value), a warning will be emitted: no Fortran derived type has been generated to correspond to the C++ class. A new derived type <code>SwigUnknownClass</code> will be generated that simply holds an opaque pointer to the C++ object. This derived type can still be used with the C interface, but it will behave as a raw <code>void*</code> pointer: no type checking will be performed on the unknown class. You must be very careful to pass the right class to the right function call.</p>
<h2 id="proxy-class-wrapper-code">Proxy class wrapper code</h2>
<p>The Fortran wrapper code generated for each function can be extended in multiple ways besides using the <code>fin</code> and <code>fout</code> typemaps. A specific function can have code prepended to it using the <code>%fortranprepend</code> macro (which is a compiler macro for <code>%feature(&quot;fortran:prepend&quot;)</code>) and appended using <code>%fortranappend</code> (which aliases <code>%feature(&quot;fortran:append&quot;)</code>.</p>
<p>For advanced cases, the function or subroutine invocation can be embedded in another layer of wrapping using the <code>%feature(&quot;shadow&quot;)</code> macro. The special symbol <code>$action</code> will be replaced with the usual invocation.</p>
<h2 id="finalization">Finalization</h2>
<p>Ideally, the <code>release</code> type-bound procedure would not have to be invoked manually, and C++ memory could be freed when the Fortran proxy object is no longer in use.</p>
<p>Fortran 2003 does have support for a special &quot;final&quot; procedure called when a dynamic or temporary object is deallocated; however, support for this feature is limited and fragile even on recent Fortran compilers. The SWIG Fortran interface does support the creation of a &quot;final&quot; procedure that calls the C++ destructor:</p>
<pre class="swig"><code>%feature(&quot;final&quot;) Foo;
%include &quot;Foo.h&quot;
</code></pre>
<p>This special feature is relatively untested and its behavior could be compiler-dependent, so extreme caution is recommended when enabling it.</p>
<h1 id="advanced">Advanced</h1>
<h2 id="fragments">Fragments</h2>
<p>The <code>%insert(section) %{ ...code... %}</code> directive can be used to inject code directly into the C/C++ wrapper file as well as the Fortran module file. The Fortran module uses several additional sections that can be used to insert arbitrary extensions to the module. For example, if an <code>%insert</code> directive is embedded within a class <code>%extend</code>, new type-bound procedures can be manually added to the derived type.</p>
<table>
<thead>
<tr><th>Name</th><th>Description</th></tr>
<tr><th colspan=2>C++ WRAPPER CODE</th></tr>
</thead>
<tbody>
<tr><td><code>begin   </code></td><td>Immediately below SWIG header comment </td></tr>
<tr><td><code>runtime </code></td><td>Run time code (beginning of .cxx file)</td></tr>
<tr><td><code>header  </code></td><td>Header code (after runtime)           </td></tr>
<tr><td><code>wrapper </code></td><td>C++ wrapper code (middle of .cxx file)</td></tr>
<tr><td><code>init    </code></td><td>Initialization code (end of .cxx file)</td></tr>
</tbody>
<thead>
<tr><th colspan=2>FORTRAN WRAPPER CODE</th></tr>
</thead>
<tbody>
<tr><td><code>fbegin     </code></td><td>Code before the `module` statement </td></tr>
<tr><td><code>fmodule    </code></td><td>Start of module:                   </td></tr>
<tr><td><code>fpublic    </code></td><td>Public interface functions         </td></tr>
<tr><td><code>fparams    </code></td><td>Enums and parameters               </td></tr>
<tr><td><code>ftypes     </code></td><td>Fortran classes                    </td></tr>
<tr><td><code>finterfaces</code></td><td>Fortran class constructors         </td></tr>
<tr><td><code>fwrapper   </code></td><td>Fortran subroutines (proxy code)   </td></tr>
</tbody>
</table>

<p>The generated C++ wrapper file looks like:</p>
<div class="sourceCode" id="cb64"><pre class="sourceCode c++"><code class="sourceCode cpp"><a class="sourceLine" id="cb64-1" data-line-number="1">{begin}</a>
<a class="sourceLine" id="cb64-2" data-line-number="2">{runtime}</a>
<a class="sourceLine" id="cb64-3" data-line-number="3">{header}</a>
<a class="sourceLine" id="cb64-4" data-line-number="4"><span class="pp">#ifdef </span><span class="ot">__cplusplus</span></a>
<a class="sourceLine" id="cb64-5" data-line-number="5"><span class="at">extern</span> <span class="st">&quot;C&quot;</span> {</a>
<a class="sourceLine" id="cb64-6" data-line-number="6"><span class="pp">#endif</span></a>
<a class="sourceLine" id="cb64-7" data-line-number="7">{wrapper}</a>
<a class="sourceLine" id="cb64-8" data-line-number="8"><span class="pp">#ifdef </span><span class="ot">__cplusplus</span></a>
<a class="sourceLine" id="cb64-9" data-line-number="9">}</a>
<a class="sourceLine" id="cb64-10" data-line-number="10"><span class="pp">#endif</span></a>
<a class="sourceLine" id="cb64-11" data-line-number="11">{init}</a></code></pre></div>
<p>The generated Fortran module looks like:</p>
<div class="sourceCode" id="cb65"><pre class="sourceCode fortran"><code class="sourceCode fortran"><a class="sourceLine" id="cb65-1" data-line-number="1"><span class="kw">{</span>fbegin<span class="kw">}</span></a>
<a class="sourceLine" id="cb65-2" data-line-number="2"><span class="kw">module</span> <span class="kw">[</span>MODULE_NAME<span class="kw">]</span></a>
<a class="sourceLine" id="cb65-3" data-line-number="3"> <span class="kw">use</span>, <span class="kw">intrinsic</span> <span class="dt">::</span> ISO_C_BINDING</a>
<a class="sourceLine" id="cb65-4" data-line-number="4"> <span class="kw">{</span>fmodule<span class="kw">}</span></a>
<a class="sourceLine" id="cb65-5" data-line-number="5"> <span class="kw">implicit</span> <span class="kw">none</span></a>
<a class="sourceLine" id="cb65-6" data-line-number="6"> <span class="dt">private</span></a>
<a class="sourceLine" id="cb65-7" data-line-number="7"> <span class="kw">{</span>fpublic<span class="kw">}</span></a>
<a class="sourceLine" id="cb65-8" data-line-number="8"> <span class="co">! module generic interfaces</span></a>
<a class="sourceLine" id="cb65-9" data-line-number="9"> <span class="kw">{</span>fparams<span class="kw">}</span></a>
<a class="sourceLine" id="cb65-10" data-line-number="10"> <span class="kw">{</span>ftypes<span class="kw">}</span></a>
<a class="sourceLine" id="cb65-11" data-line-number="11"><span class="kw">interface</span></a>
<a class="sourceLine" id="cb65-12" data-line-number="12"> <span class="kw">{</span>finterfaces<span class="kw">}</span></a>
<a class="sourceLine" id="cb65-13" data-line-number="13"><span class="kw">end interface</span></a>
<a class="sourceLine" id="cb65-14" data-line-number="14"><span class="co">contains</span></a>
<a class="sourceLine" id="cb65-15" data-line-number="15"> <span class="kw">{</span>fwrapper<span class="kw">}</span></a>
<a class="sourceLine" id="cb65-16" data-line-number="16"><span class="kw">end module</span></a></code></pre></div>
<h2 id="known-issues">Known Issues</h2>
<p>A number of known limitations to the SWIG Fortran module are tracked at <a href="https://github.com/sethrj/swig/issues/59" class="uri">https://github.com/sethrj/swig/issues/59</a> .</p>
</body>
</html>
