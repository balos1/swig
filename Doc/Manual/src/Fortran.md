<!--
This document is formatted with [Github-flavored
Markdown](https://github.github.com/gfm/)

Run with:
    pandoc --from=gfm  --metadata title="SWIG and Fortran" \
    --toc --standalone -H src/style.css -o Fortran.html src/Fortran.md

Authored by Seth R Johnson
--
-->

# Overview 

This chapter describes how to create interfaces to C and C++ data and functions
in the target language of Fortran, a highly static, long-lived scientific
programming language.
The primary motivation for adding the Fortran language to SWIG is to provide an
automated means to adapt massively parallel scientific codes to modern solvers
and GPU-accelerated kernels in the Trilinos numerical library package.
But in addition to this useful capability, SWIG-Fortran has potential to
simplify and accelerate numerous existing Fortran codes that do not require
advanced numerical solvers.
By implementing automated coupling of C++ libraries to Fortran, we open up a
new world of capability to Fortran users.

# Fundamental concepts

SWIG generates simple, flat C functions that provide access to underlying C/C++
data and functions that may operate on complex data types.
Fortran 2003 introduced features designed to finally provide standardized
interactions between Fortran and ANSI C.  The wrapper functions generated by
SWIG-Fortran take and return only these `ISO_C_BINDING`-compatible data
types. These functions are responsible for converting any complex C
datatypes to simpler ones compatible with Fortran.

In addition to generating a C++ file of wrapper code, SWIG generates a Fortran
module (one per `%module` SWIG directive).
In the private "interface" section of this module, SWIG generates function
interface declarations with the `BIND(C)` qualifier that exactly mirror the
generated wrapper functions.
In SWIG, all of the C-generated wrapper functions are prefixed with `swigc_`,
so all of these interface functions likewise start with `swigc_`. 

Finally, SWIG generates additional Fortran code that translates the simple
function arguments and return values into their Fortran equivalents.
For simple data types this conversion is simply assignment, but other complex
transformations can be performed that allow better native integration of C++
with Fortran.
For example, a `const int[3]&` return value can be transformed to
Fortran length-3 array `pointer` instead of being left as an opaque C pointer.

SWIG also generates "proxy" classes: thin Fortran 2003 TYPE declarations
that bind `swigc_` functions to manipulate C++ class instances in Fortran.

## Nomenclature

The terminology in C/C++ and Fortran is different enough to be potentially
confusing to a user of either one language or the other. The author is much
more familiar with C++ than Fortran but has endeavored to use the correct
Fortran terms when describing the Fortran implementation. The following table
roughly illustrates some of the differences between the two languages:

| C/C++                            | Fortran                     |
|----------------------------------|-----------------------------|
| struct/class                     | derived type                |
| function                         | procedure                   |
| member function                  | type-bound procedure        |
| function that returns void       | subroutine                  |
| function that returns non-void   | function                    |
| overloaded function              | generic interface           |
| floating point number            | real                        |

## Running SWIG

Suppose that we have a SWIG interface file `example.i` with the following
contents:
```swig
/* File: example.i */
%module forexample

%{
/* include header */
#include "cexample.h"
%}

%include "cexample.h"
```
(and `cexample.h` contains the simple function declaration:)
```c
int fact(int n);
```

To generate SWIG Fortran wrappers for this file, run
```sh
$ swig -fortran example.i
```
and SWIG will create two files: a C interface file containing something like
```c
/* SNIP */
/* include header */
#include "cexample.h"
/* SNIP */
SWIGEXPORT int swigc_fact(int const *farg1) {
  int fresult;
  int arg1;
  int result;
  
  arg1 = *farg1;
  result = (int)fact(arg1);
  fresult = result;
  return fresult;
}
/* SNIP */
```
and a Fortran interface file with something like:
```fortran
module forexample
 use, intrinsic :: ISO_C_BINDING
 implicit none
 public :: fact
private
interface
 function swigc_fact(farg1) &
 bind(C, name="swigc_fact") &
  result(fresult)
  use, intrinsic :: ISO_C_BINDING
  integer(C_INT) :: fresult
  integer(C_INT), intent(in) :: farg1
 end function
end interface
contains
 function fact(n) &
  result(swig_result)
  use, intrinsic :: ISO_C_BINDING
  integer(C_INT) :: swig_result
  integer(C_INT), intent(in) :: n
  integer(C_INT) :: fresult 
  integer(C_INT) :: farg1 
  farg1 = n
  fresult = swigc_fact(farg1)
  swig_result = fresult
 end function
end module forexample
```

The `%module` declaration in the `.i` file resulted in the file names
`forexample.f90` and the name in `module forexample`; file name `example.i`
resulted in the C wrapper file by default being named `example_wrap.c`, and the
`#include` command was explicitly inserted into the C wrapper file
`example_wrap.c`. The `%include` command in the `.i` file directed SWIG to
parse the header file `cexample.h` and generate an interface for the function
declaration that it discovered.

In the generated C wrapper code above, `int swigc_fact(int const *farg1)` is
the wrapper code generated by SWIG to provide a Fortran-compatible interface
with the C function `fact`; the `function swigc_fact(farg1)` interface in
Fortran is the exact equivalent of that C function; and the "public" function
`fact` in the `contains` section of the Fortran module is the Fortran proxy
function generated by SWIG.

Note that since this function takes and returns
simple data types, the C and Fortran wrapper functions have some code that
could be easily simplified by hand. However, for more complex data types, SWIG
shows its power by generating complex expressions that seamlessly translate
between C and Fortran data types without requiring user intervention.

## Compiling a simple Fortran program

Several examples are provided in the SWIG source code under
`Examples/fortran/`. In the `barefunctions` example, the Fortran `main` program
can be compiled using the following sequence of commands:
```sh
swig -fortran -c++ bare.i
$CXX -c bare_wrap.cxx
$CXX -c bare.cxx -o barecxx.o
$FC gfortran -c bare.f90
$FC runme.f90 bare.o bare_wrap.o barecxx.o -lstdc++ -o run.exe
```
Note that since this was a C++ program, the `c++` option must be passed to SWIG
and `-lstdc++` must be passed to the final link command.

## Compiling more complex Fortran/C/C++ programs

The figure below shows how C++, SWIG, and Fortran code can be integrated into
libraries and linked to form executables. The file icons are user-written
files; circles are executables; flat cylinders are generated on-disk files; and
the final box is the executable. The arrow signifies "generates" or "is used
by."

<img src="fig/swig-fortran-data.png" alt="SWIG python data flow" height="504"
width="352"/>

We provide CMake modules and commands to simplify this process; again, see the
example directories for usage instructions.

<!-- ###################################################################### -->

# Basic Fortran/C data type interoperability

The Fortran SWIG module relies on Fortran 2003's C interoperability features,
both the `ISO_C_BINDING` intrinsic module and the specifications of the
standard. Every effort has been made to conform to the standard in the
translation layer between C++ and Fortran and to eliminate potential pitfalls
of interoperability.

We anticipate that future extensions of Fortran/C interoperability will
increase the capability of the SWIG wrapper interface.
However, many features of C and C++ are outside the scope of Fortran's
interoperability features.  Even some features that *are* interoperable,such as
enumerations and structs, have capabilities that do
not map between the two languages. With SWIG-Fortran we attempt to extend the
Fortran/C++ mapping as much as possible, keeping in mind that Fortran and C are
inherently different languages designed at different times with different
purposes in mind.

## Fundamental types

SWIG maps a number of the fundamental C types to their ISO Fortran equivalents
via the `use, intrinsic :: ISO_C_BINDING` statement. The types mapped directly
by SWIG are:

| C type          |   Fortran type          |
|-----------------|-------------------------|
| `unsigned char `| `integer(C_INT8_T)   `  |
| `short         `| `integer(C_SHORT)    `  |
| `unsigned short`| `integer(C_SHORT)    `  |
| `int           `| `integer(C_INT)      `  |
| `unsigned int  `| `integer(C_INT)      `  |
| `long          `| `integer(C_LONG)     `  |
| `unsigned long `| `integer(C_LONG)     `  |
| `long long     `| `integer(C_LONG_LONG)`  |
| `size_t        `| `integer(C_SIZE_T)   `  |
| `float         `| `real(C_FLOAT)       `  |
| `double        `| `real(C_DOUBLE)      `  |
| `void*         `| `type(C_PTR)         `  |

Pointers and references to the fundamental types are returned as scalar Fortran
pointers: because the C return value does not contain any information about the
shape of the data being pointed to, it is not possible to directly construct an
array from a pointed-to value.

However, advanced typemaps can be constructed (and indeed are provided by the
SWIG Fortran library) that *can* return that information or extend the Fortran
interface to obtain the additional information needed to return an array
pointer.

The astute reader may notice the omission of `C_BOOL` from the above table.
Because of the different treatment of booleans in C and Fortran, guaranteeing
the sizes of the `bool` is equivalent in the two languages does _not_ guarantee
the equivalence of their values. See [this discussion topic](https://software.intel.com/en-us/forums/intel-fortran-compiler-for-linux-and-mac-os-x/topic/594856)
for details of the subtle compatibility, but in brief, Fortran's `.true.` is
defined by having the least significant bit set to `1`, whereas C defines it
as any nonzero value. So the value `2` would be `true` in C but `false` in
Fortran. A special typemap inserts wrapper code to explicitly convert 
booleans between the two languages.

The built-in type wrapping also omits standard C character `char`
to prevent ambiguity of wrapping character arrays (`char*` or `CHARACTER,
DIMENSION(:)`) from strings (`char*` or `CHARACTER(LEN=*)`).

## Pointers and references

C pointers and mutable references are treated as Fortran pointers. Suppose a C
function that returns a pointer to an array element at a given index:
```c
double* get_array_element(int x);
```

This generates the following Fortran interface:
```fortran
function get_array_element(x) &
      result(swig_result)
  use, intrinsic :: ISO_C_BINDING
  real(C_DOUBLE), pointer :: swig_result
  integer(C_INT), intent(in) :: x
  type(C_PTR) :: fresult 
  integer(C_INT) :: farg1 

  farg1 = x
  fresult = swigc_get_array_element(farg1)
  call c_f_pointer(fresult, swig_result)
end function
```

To set the element at array index 2 to the value 512, 
```fortran
real(C_DOUBLE), pointer :: rptr
rptr => get_array_element(2)
rptr = 512.0d0
```
Note, and this is **very important**, that a function returning a pointer must
not be *assigned*; the *pointer assignment* operator `=>` must be used.

Mutable references are treated identically. However, *const* references to
primitive types are treated as values:
```c++
const double& get_const_array_element(int x);
```
will generate
```fortran
function get_const_array_element(x) &
    result(swig_result)
  use, intrinsic :: ISO_C_BINDING
  real(C_DOUBLE) :: swig_result
  integer(C_INT), intent(in) :: x
  real(C_DOUBLE) :: fresult 
  integer(C_INT) :: farg1 

  farg1 = x
  fresult = swigc_get_const_array_element(farg1)
  swig_result = fresult
end function
```
which must be called like
```fortran
real(C_DOUBLE) :: rval
rval = get_const_array_element(2)
```

Combining the two examples, you could copy value of element 3 to element 2 with
the following code block:
```fortran
real(C_DOUBLE), pointer :: rptr
rptr => get_array_element(2)
rptr = get_const_array_element(3)
```
First the pointer is assigned, then the pointed-to data is assigned.

## Strings

Fortran's interoperability specifications prohibit using `C_LOC` on variables
with length type parameters: thus the standard `character(len=*)` type cannot
be natively passed to C. Instead, SWIG injects small helper functions that
convert between strings and arrays of characters. The character arrays are then
passed through the interface layer to C, which can reconstruct the full string.

Because the actual Fortran string length is passed to C during this process,
character arrays with the null character can be converted to byte objects
without unexpected string truncation.

Currently SWIG provides typemaps (see the Typemaps section) that allow
transparent conversion between Fortran character arrays and C++ `std::string`
objects. Automatic wrapping for null-terminated C strings (with signature
`const char*`) is not implemented yet, but there is no fundamental obstacle in
doing so.

## Arrays

SWIG supports a subset of direct Fortran array translation. If a
single-dimensional array size is explicitly specified in a C function's
signature, the corresponding argument will be an explicit-shape Fortran array.

One caution is that occasionally arrays will be defined using nontrivial C
expressions rather than explicit integers. Even though these can be evaluated
by C at compile time, the unevaluated expression is propagated into the Fortran
wrapper code where it will fail.

```c
int global_data1[8]; /* OK */
int global_data2[];  /* OK */
int global_data3[sizeof(int)];  /* ERROR */
```

## Classes and structs

In C++, the only difference between a `struct` and a `class` is the default
*access specifier*: `public` for `struct` and `private` for `class`. As with
the rest of SWIG, only public methods and data are wrapped.

These are both wrapped as *derived types* in Fortran. By default, these derived
types are "proxy" classes, which hold a C pointer to a C++ class instance.
Roughly speaking, classes are mapped from
```c++
class Foo {
public:
  void bar();
};
```
becomes
```fortran
type :: Foo
  type(SwigClassWrapper), public :: swigdata
contains
  procedure :: bar => swigf_Foo_bar
end type
```

In certain circumstances, C classes can be wrapped natively as Fortran
`BIND(C)` derived types, so that the underlying data can be shared between C
and Fortran without any wrapping needed. Specified standard-layout structs can
use the `%bindc` feature to translate
```c++
struct BasicStruct {
  int foo;
  double bar;
};
```
to
```fortran
type, bind(C) :: BasicStruct
  integer(C_INT), public :: foo
  real(C_DOUBLE), public :: bar
end type
```
Currently this feature must be activated using a special macro
`%fortran_bindc_struct`:
```swig
%fortran_bindc_struct(BasicStruct);
```

In both cases, unlike many other SWIG languages, the proxy code produced by
Fortran is *strongly typed*: mistakenly using the wrong type will result in a
compiler error as opposed to a runtime error.

## Ignored or unimplemented forward-declared structs and classes

Some functions may include references or pointers to classes that are not
wrapped by Fortran proxy functions. In these cases, an opaque derived type
called `SwigUnknownClass` will be generated and used as a placeholder for the
argument or return value. These could theoretically be passed between wrapped
SWIG functions, although no type checking will be performed to ensure that the
unknown classes are the correct types.

## Enumerations

Fortran 2003 supports C-bound enumerations but
[does not allow them to be typed](https://www.ibm.com/support/knowledgecenter/SS2MB5_14.1.0/com.ibm.xlf141.bg.doc/language_ref/enum.html):
in effect, enumerators are simply a set of loosely grouped compile-time integer
constants.

To associate a C enumeration name with the Fortran
generated wrappers, SWIG generates an additional enumeration with the C class
name and a dummy value of `-1`. The enumeration generated from the C code
```c
enum MyEnum {
    RED = 0,
    GREEN,
    BLUE,
    BLACK = -1
};
```
looks like:
```fortran
 enum, bind(c)
  enumerator :: MyEnum = -1
  enumerator :: RED = 0
  enumerator :: GREEN = RED + 1
  enumerator :: BLUE = GREEN + 1
  enumerator :: BLACK = -1
 end enum
```
 
These are then treated as standard C integers elsewhere in the code; on the
Fortran side this is achieved with the dummy argument type
`integer(kind(MyEnum))`.

Some C++ enumeration definitions cannot be natively interpreted by a Fortran
compiler (e.g. `FOO = 0x12,` or `BAR = sizeof(int),`), so these are defined in
the C++ wrapper code and _bound_ in the Fortran wrapper code:
```fortran
integer(C_INT), protected, public, &
   bind(C, name="swigc_FOO") :: FOO
```
The `%enumerator` and `%noenumerator` features can be used to explicitly enable
and disable treatment of a C++ `enum` as a Fortran enumerator.

## Function pointers

It is possible to pass function pointers both from C to Fortran and from
Fortran to C using SWIG. Currently function pointers only work with
user-created C-linkage functions as described below, but we plan to extend
function callbacks so that data can be translated through wrapper functions.

Another planned extension for function pointers is to automatically generate
the necessary *abstract interface* code required by Fortran to interpret the
function pointer. Currently, function pointer variables
simply generate opaque `type(C_FUNPTR)` objects.

Calling C functions from Fortran as pointers can be done using [c_f_procpointer](https://software.intel.com/en-us/node/679091):
```fortran
subroutine CallIt(cp) bind(c)
  use, intrinsic :: iso_c_binding
  type(c_funptr), intent(in) :: cp
  abstract interface
    subroutine Add_Int(i) bind(c)
      import
      integer(c_int), intent(inout) :: i
    end subroutine Add_Int
  end interface
  procedure(Add_Int), pointer :: fp
  integer(c_int) :: j

  call c_f_procpointer(cp, fp)
  j = 1
  call fp(j)
end subroutine CallIt
```

See the `funcptr` example in SWIG for an example of the current callback
functionality in practice.

## Handles and other oddities

Most combinations of pointers and references (such as `int**`, `int* const*`,
`int*[3]`, `int*&`) are treated as opaque C pointers. They can be passed
through the Fortran/C interface but currently have no special meaning or
operations in generated Fortran code.

```c
double** get_handle();
```
becomes
```fortran
function get_handle() &
    result(swig_result)
  use, intrinsic :: ISO_C_BINDING
  type(C_PTR) :: swig_result
end function
```

Similarly, member function pointers (bound to a member function of a particular
class instance) are supported as opaque Fortran objects.

<!-- ###################################################################### -->

# Basic C/C++ features

This section describes how C and C++ language features can generate Fortran
wrapper code.

## Functions

Functions in C/C++ are *procedures* in Fortran. Their arguments correspond
directly between the two languages: one argument in the C code requires one
argument in the Fortran proxy.
(An exception is that C arguments can be ignored by swig using the
`%typemap(in, numinputs=0)` directive in SWIG.) A function in C/C++ with a
`void` return value will construct a `subroutine` in Fortran, and a function
returning anything else will yield a Fortran `function`.

Each function in SWIG has a unique "symbolic name" or *symname* bound to it.
The *symname* must be compatible with C linkage, so namespaces, templates,
and overloads are incorporated into the symname, but they are often just the
same as the bare function name.
<!--
For example, a function 
```c++
namespace foo {
template<typename T>
void bar(T arg);
}
```
and instantiated with
```swig
%template(bar_dbl) foo::bar<double>;
```
might a symbolic name `bar_dbl
-->

SWIG will generate a wrapper function in the C++ file named `swigc_$symname`,
where `$symname` is replaced with the symname. A corresponding private `BIND(C)`
interface statement will be generated in the Fortran interface module. This
wrapper function is responsible for translating the function's arguments
and return value into types compatible with the Fortran/C
interoperability features and calling the C++ function.

In the Fortran module, SWIG generates a public procedure `$symname` translates
the C interface data into Fortran data types. This interface is the one used by 
Fortran application codes.

There is an important exception to the naming scheme described above:
overloaded functions in C++ create private procedures
suffixed with unique strings. These procedures are then combined under a
*separate module procedure* that is given a public interface with the original
symbolic name.

## Global variables

Global variables in SWIG are wrapped with "getter" and "setter" functions. In
the case of a global C++ variable
```c++
namespace foo {
extern int global_counter;
}
```
SWIG will generate functions with interfaces
```fortran
subroutine set_global_counter(value0)
  use, intrinsic :: ISO_C_BINDING
  integer(C_INT), intent(in) :: value0
end subroutine
```
and 
```fortran
function get_global_counter() &
  result(swigf_result)
  use, intrinsic :: ISO_C_BINDING
  integer(C_INT) :: swigf_result
end function
```
Although no type conversion is needed for simple integers, other global data
types would require special wrapper code in these functions.

Currently, global C/Fortran-compatible variables are treated the same as C++
data, but in the future we plan to expand the `%bindc` feature to directly wrap
```c++
extern "C" {
extern int global_counter_c;
}
```
as a C-bound common block variable bound
```fortran
integer(C_INT), bind(C, name="global_counter_c") :: global_counter_c
```

### Global constants

Global constant variables (whether declared in C++ headers with `const` or in
a SWIG wrapper with `%constant`) of native types can be wrapped as Fortran
parameters:
```c++
%parameter approx_pi;
const double approx_pi = 3.1416;
```
will be translated to
```fortran
 real(C_DOUBLE), parameter, public :: approx_pi = 3.1416_C_DOUBLE
```
If the variable is defined in the header file and is a simple integer, this
feature will be enabled by default. It can be explicitly enabled or disabled
using the `%parameter` and `%noparameter` directives.


## Classes

As mentioned previously, C++ classes are transformed to Fortran *derived
types*. These types have *bound procedures* that mirror the C++ *member
functions*. 

### Member functions

### Member data

### Constructors and Destructors

Because Fortran is not a stack-based language like C (where variables enter and
leave scope by being pushed onto and popped off the memory stack), generally
speaking all data are static -- they occupy the same location in memory,
determined at compile time. 

## Exceptions

<!-- ###################################################################### -->

# Typemaps

SWIG Fortran extends the typemap system of SWIG with additional typemaps. There
are two new typemaps to declare the data types used by Fortran and C in the
intermediate layer, and two typemaps for translating the intermediate layer
types to the final Fortran types.

To pass Fortran-2003 compatible `BIND("C")` or `ISO_C_BINDING` types between
C++ and Fortran, you
must declare a compatible `ctype` and `ftype`. The `ctype` is the C datatype
used by the wrapper and intermediate layer, and `ftype` is the equivalent
Fortran datatype. These datatypes generally must be either fundamental types or
structs of fundamental types. For example, as described in `Fundamental types`
section, the `int` C type corresponds to the `integer(C_INT)` Fortran type.

Note that fundamental types include the opaque
pointer `void*` and its Fortran equivalent `type(C_PTR)` as well as function
pointers and the opaque Fortran equivalent `type(C_FUNPTR)`.

## Fortran proxy datatype translation

The `fin` and `fout` typemaps are Fortran proxy wrapper code analogous to the
`in` and `out` in the C wrapper code: they are used for translating native
Fortran objects and types into types that can be transmitted through the C
layer. For example, to pass a class by reference, the Fortran class
`class(SimpleClass) :: self` is converted to the corresponding C class via the
stored C pointer using the `fin` typemap, which is expanded to:
```fortran
farg1 = self%swigdata%ptr
```
This argument is then passed into the C function call:
```fortran
fresult = swigc_make_class(farg1)
```
and the output is translated back via the `fout` typemap, which in this case expands to:
```fortran
swig_result%swigdata%ptr = fresult
```
## Special overrides for return variables

Sometimes a return type in C++ needs additional contextual information to be
meaningful in Fortran. For example, a returned pointer may be the first element
in a C array but requires a size to be used as an array. Since special typemaps
cannot be applied to output variables like they can for inputs (i.e.
`%typemap(in) int* OUTPUT`), we provide a `%feature` directive for additional
customization.

Consider a vector-like C++ class:
```c++
class Array
{
public:
  double* data();
  int size();
};
```

With typemaps alone, it's impossible to convert the return value from `data` to
a sized array pointer in Fortran. (By default, `data` is interpreted as a
scalar pointer.) Since the SWIG `%feature` directive can be applied to specific
functions and methods, we can use `%feature("ftype")` and `%feature("fout")` to
override the `%typemap("ftype") double*` and `%typemap("fout") double*`:
```swig
%feature("ftype") Array::data %{
real(C_DOUBLE), dimension(:), pointer
%}
%feature("fout") Array::data %{
call c_f_pointer($1, $result, [self%size()])
%}
```

## Allocating local Fortran variables in wrapper codes

Advanced SWIG users may know that 
```swig
%typemap(in) int (double tempval) { /.../ }
```
is a way to declare a temporary variable `tempval` in the C wrapper code. The
same feature is emulated in the special typemaps `findecl` and `foutdecl`,
which are inserted into the variable declaration blocks when the corresponding
types are used. If `findecl` allocates a temporary variable, the `ffrearg`
typemap (analogous to the `freearg` typemap for C `in` arguments) can be used
to deallocate it.

An example for returning a native `allocatable` Fortran string from a C++
string reference must declare a temporary array pointer to the C data, then
copy the result into a Fortran string.
```swig
%typemap(ftype, out="character(kind=C_CHAR, len=:), allocatable")
    const std::string&
"character(kind=C_CHAR, len=*), target"

// Fortran proxy translation code: temporary variables for output
%typemap(foutdecl) const std::string&
%{
 integer(kind=C_SIZE_T) :: $1_i
 character(kind=C_CHAR), dimension(:), pointer :: $1_chars
%}

// Fortran proxy translation code: convert from imtype $1 to ftype $result
%typemap(fout) const std::string&
%{
  call c_f_pointer($1%data, $1_chars, [$1%size])
  allocate(character(kind=C_CHAR, len=$1%size) :: $result)
  do $1_i=1,$1%size
    $result($1_i:$1_i) = $1_chars($1_i)
  enddo
%}
```

## Special class typemaps

To facility the wrapping and customizability of C++ classes, there are a few
additional special typemaps that only apply to classes. They generally should
not need to be modified.

The `fdata` typemap declares the data object that is stored by the Fortran
proxy class. Note that only the base class of any inheritance hierarchy
contains this data.

The `fdestructor` typemap becomes the Fortran wrapper code for the `release`
type-bound procedure. The special token `$action` is replaced by the call to
the C wrapper for the destructor. Currently, all classes have the same
destructor action but this may change. (TODO: should this be a `%feature`? Or
should `%feature("unref")` be a typemap?)

## Fortran interoperability

There are a few ways to make C++ code interact more cleanly with Fortran. For
example, many interfaces take a `std::string`, but it would be _really_
convenient not to have to instantiate a string class for each argument. To this
end, a special typemap is provided that transparently converts native Fortran
character strings to and from `std::string` classes.

To use it globally and prevent the `std::string` wrapper class from being
instantiated, do the following:
```swig
%ignore std::string;
%include <std_string.i>
%apply const std::string& NATIVE { const std::string& };
```
You can of course selectively `%apply` that typemap like any other SWIG
typemap. To apply it only to the output of a particular class `const
std::string& get_foo()`, you can use
```swig
%apply const std::string& NATIVE { const std::string& get_foo };
```

Similarly, instantiating a `std::vector` creates a typemap that allows native
treatment of array inputs and outputs. This is used in the ForTrilinos to treat
`ParameterList` embedded arrays as native Fortran arrays for convenience.

One other note to be made about Fortran interoperability concerns the mismatch
between default Fortran integers and C++'s `size_type`, which is often used as
a parameter. The mismatch requires that users awkwardly cast values when
passing into function calls:
```fortran
call my_vector%resize(INT(n,C_LONG))
```
This nuisance can be simply avoided by replacing occurrences of C's size type
with the native Fortran integer type:
```swig
%apply int { std::size_t }
```

<!-- ###################################################################### -->

# Direct C binding

## Generating C-bound Fortran types from C structs

The Fortran SWIG module provides a macro `%fortran_bindc_struct` that
creates a native Fortran `TYPE` for simple C structs. In C++, these structs
must be "standard layout", i.e. compatible with C. (Roughly speaking, there
must be no virtual member functions, inheritance, or C++-like member data.)

Calling `%fortran_bindc_struct(Foo)` inhibits default constructor/destructor
generation for the class, and it sets up the necessary type definitions to
treat the struct as a fundamental type.

Every member of the struct must be `BIND(C)` compatible. This is enforced with
a separate typemap `bindc` that translates the member data to Fortran type
members. For example, the basic `int` mappings are defined (using macros) as:

```swig
%typemap(bindc) int      "integer(C_INT)"
%typemap(bindc) int*     "type(C_PTR)"
%typemap(bindc) int[ANY] "integer(C_INT), dimension($1_dim0)"
%typemap(bindc) int[] = int*;
```

The `bindc` typemap is used when wrapping global constants as well.

## Interfaces with Fortran C-bound types

If types defined in the SWIG Fortran module are to be used as part of the
interface (as is the case with structs), it is necessary to "import" the type
into the interface to use it. This is accomplished by the `import` keyword
argument to the `imtype` typemap. For
example, whenever the following typemap is used in the intermediate wrapper:
```swig
%typemap(imtype, import="SwigfArrayWrapper")  FooArray
  "type(SwigfArrayWrapper)";
```
an `import` directive will be inserted into the Fortran proxy
function:
```fortran
module thinvec
 use, intrinsic :: ISO_C_BINDING
 implicit none

 type, public, bind(C) :: SwigfArrayWrapper
   type(C_PTR), public :: data
   integer(C_SIZE_T), public :: size
 end type
 interface
 subroutine swigc_foo(farg1) &
   bind(C, name="swigc_foo")
   use, intrinsic :: ISO_C_BINDING
   import :: SwigfArrayWrapper    ! Will not compile without this line
   type(SwigfArrayWrapper) :: farg1
 end subroutine
```

This extra typemap trickery should only be needed if you're generating bound
types without using the `%fortran_bindc_struct` macro.

## Generating direct Fortran interfaces to C functions

In addition to generating functions with translation code, it is
also possible to specify that a function be directly *bound* and not *wrapped*.
For this feature to work correctly, all function arguments and return types
must be inherently Fortran/C interoperable. If using C++, the function must be
defined using `extern "C"` linkage; and in fact, when SWIG is asked to wrap a
function with that linkage, it defaults to binding it. Use the `%nobindc
my_func_name;` feature to suppress this behavior.

The C++ code:
```C++
extern "C" {
// These functions are simply bound, not wrapped.
void print_sphere(const double origin[3], const double* radius);
}
```
is automatically translated into
```fortran
subroutine print_sphere(origin, radius) &
    bind(C, name="print_sphere")
  use, intrinsic :: ISO_C_BINDING
  real(C_DOUBLE), dimension(3), intent(in) :: origin
  real(C_DOUBLE), intent(in) :: radius
end subroutine
```

<!-- ###################################################################### -->

# SWIG-generated Fortran derived types

Each C++ class (excepting types wrapped as `BIND(C)` structs) creates a "proxy"
class in the Fortran module: it is a thin wrapper that binds a C++ pointer to
the corresponding SWIG-wrapped C++ methods. These classes are *strongly typed*:
the compiler enforces type checking instead of runtime type checking being
performed (which is the case with many other SWIG-wrapped languages).

Memory management in Fortran is vastly different from C and C++: it is designed
for much simpler computers of the past where every subroutine and variable in
the computer memory had a specific address. Effectively, all data in Fortran
(with the exception of functions declared `RECURSIVE`) is static: it will be
initialized once and will persist between leaving and reentering a subroutine.

This presents significant difficulties when working with C++ classes, which
often are predicated on having limited scope so that their destructor is called
to release resources. We have implemented a partial workaround that tracks
memory ownership inside Fortran and C++; as a bonus it enables const
correctness.

Every proxy class holds a single piece of data, a small C-bound struct named
`SwigfClassWrapper`, which contains two simple members: a pointer to C-owned
memory, and an enumeration that tracks the ownership of that memory.

## Memory management

For reasons of simplicity, a single Fortran proxy class must be able to act as a
value, a pointer, or a reference. They must be able to be created and destroyed
without double-deleting memory. Finally, and most frustratingly, C++ functions
must be able to return both new'd data and referenced data to Fortran, and
assignment between Fortran classes must preserve memory association.

[ Footnote: Fortran pointers cannot be used for returning references and C
pointers, because the pointed-to object needs to be a *proxy* class rather than
a C++ class. ]

The complicating issue with assignment is that Fortran's "dummy argument" for
the return result is `intent(out)`, preventing its previous contents (if any)
from being modified or deallocated. At the same time, the assignment operator
must behave correctly in both of these assignments, which are treated
identically:
```fortran
 type(Foo) :: a, b
 a = make_foo()
 b = a
```
Note that unlike Python, `b` is not a pointer to `a`; and unlike C++, `b` is
not copy-constructed from `a`. Instead, `a` is assigned to `b` using the
`assignment(=)` operator. Likewise, `a` is not "constructed" on the second line: 
there is no return value optimization as in C++. Instead, `make_foo` returns a
temporary `Foo`, and that temporary is assigned to `a`.

Because these two assignments are treated equally and a temporary is created in
only one of them, we have to be clever to avoid leaking or double-deleting
memory.

Ideally, as was done in Rousson's implementation of Fortran shared pointers, we
could rely on the `FINAL` operator defined by Fortran 2003 to release the
temporary's memory. Unfortunately, even 15 years after the standard was
ratified, support for `FINAL` is patchy and unreliable.

Our solution to this limitation is to have the `Foo` proxy class store not only
a pointer to the C data but also a state enumeration `self%swigdata%mem` that
describes memory ownership. The enumeration needs to have at least three options:
- The memory is *owned* by the proxy class (and must be deleted when calling
  `release()`);
- The proxy class is a *reference* to memory owned by C/C++ (returned by either
  a raw pointer or a reference);
- The memory is being allocated and returned from a function, but it must be
  captured by the left hand side.

This last option is roughly analogous to the behavior of the deprecated
`std::auto_ptr`, which was the predecessor to C++11's `move` semantics.
Besides the above flags, we also define an "uninitialized" state for
convenience, and a "const reference" state to enable const correctness. These
flags are set by the SWIG `out` typemaps in the C wrapper code: if memory is
being allocated, the return flag is `MOVE`; if a pointer is being returned,
`REF` (or `CREF` in the const case) is used.

The final trick is to implement an assignment operator that correctly copies,
allocates, or moves memory based on the flags on the left- and right-hand sides,
and sets a new memory state on the recipient. By resetting the state flag in a
generic assignment operator, we guarantee that *only* temporary classes will
ever have the `MOVE` state.

For the operation `self = other`, where `other` may be a return value from a
function or another class, the following actions are taken. (In the example,
both classes are of type `This`, and `pself` and `pother` are the pointers
being managed.)

| Self   | Other        | *Action*                                |
| ---    | -----        | --------                                |
| NULL   | NULL         | (none)                                  |
| NULL   | MOVE         | `pself = pother;`                       |
| NULL   | OWN          | `pself = new This(pother);`             |
| NULL   | REF/CREF     | `pself = pother;`                       |
| OWN    | NULL         | `delete pself; pself = NULL;`           |
| OWN    | MOVE         | `*pself = move(*pother); delete pother;`|
| OWN    | OWN          | `*pself = *pother;`                     |
| OWN    | REF/CREF     | `*pself = *pother;`                     |
| REF    | NULL         | `pself = NULL`                          |
| REF    | MOVE         | `*pself = move(*pother); delete pother;`|
| REF    | OWN          | `*pself = *pother; `                    |
| REF    | REF/CREF     | `*pself = *pother;`                     |
| CREF   | NULL         | `pself = NULL`                          |
| CREF   | MOVE         | (error)                                 |
| CREF   | OWN          | (error)                                 |
| CREF   | REF/CREF     | (error)                                 |
                                                                
The above operations are designed to preserve C++ semantics: if an proxy object
owning memory is assigned, then any existing objects pointing to that memory
will reflect the newly assigned value.

The fact that some classes disallow combinations of copy/move
constructors and assignment complicates the task of evaluating the above
actions. SWIG's built-in parsing of class features is usually sufficient to
determine when a class can be copy-assigned or copy-constructed. If C++11 is
enabled, standard library type traits override the SWIG-parsed features and
additionally enable move construction and move assignment.

Memory can still be leaked, of course, by calling `make_foo()` without
capturing and releasing the result, or by failing to call `release` on a proxy
class.

## Function overloading

Function overloading is when two or more free functions share a name but have
different arguments. This is implemented using *generic interfaces*. Each
overloaded function gets a unique symbolic internal name, and they are bound
together. For an overloaded free function `myfunc` in C++, SWIG will generate
two private procedures and add an interface to the module specification:
```fortran
 public :: myfunc
 interface myfunc
  module procedure myfunc__SWIG_0, myfunc__SWIG_1
 end interface
```

If a member function `doit` of class `Action` is overloaded, a generic binding will be
generated inside the Fortran proxy derived type:
```fortran
  procedure, private :: doit__SWIG_0 => swigf_Action_doit__SWIG_0
  procedure, private :: doit__SWIG_1 => swigf_Action_doit__SWIG_1
  generic :: doit => doit__SWIG_0, doit__SWIG_1
```

It should be noted that a function that returns `void` cannot be overloaded
with a function that returns anything else: generic interfaces must be either
all subroutines or all functions. Use SWIG's `%ignore` statement to hide one or
the other:
```swig
void cannot_overload(int x);
int  cannot_overload(int x, int y);
%ignore cannot_overload(int x);
```

## Opaque class types

SWIG's default Fortran type (the `ftype` typemap) for generic types such as
classes (`SWIGTYPE`) is:
```swig
%typemap(ftype) SWIGTYPE "type($fclassname)"
```
The special symbol `$fclassname` is replaced by the symbolic name of the class
that matches the typemap. For example, if `std::vector<double>` is
instantiated:
```swig
%template(Vec_Dbl) std::vector<double>;
```
then `Vec_Dbl`, the name of the derived type, will replace `$fclassname`.

If a class has *not* been wrapped but is encountered (e.g. in a function
argument or return value), a warning will be emitted: no Fortran
derived type has been generated to correspond to the C++ class. A new derived
type `SwigUnknownClass` will be generated that simply holds an opaque pointer
to the C++ object. This derived type can still be used with the C interface,
but it will behave as a raw `void*` pointer: no type checking will be performed
on the unknown class. You must be very careful to pass the right class to the
right function call.

## Proxy class wrapper code

The Fortran wrapper code generated for each function can be extended in
multiple ways besides using the `fin` and `fout` typemaps. A specific function
can have code prepended to it using the `%fortranprepend` macro (which is a
compiler macro for `%feature("fortran:prepend")`) and appended using
`%fortranappend` (which aliases `%feature("fortran:append")`.

For advanced cases, the function or subroutine invocation can be embedded in
another layer of wrapping using the `%feature("shadow")` macro. The
special symbol `$action` will be replaced with the usual invocation.

# Advanced


## Fragments

The `%insert(section) %{ ...code... %}` directive can be used to inject code
directly into the C/C++ wrapper file as well as the Fortran module file. The
Fortran module uses several additional sections that can be used to insert
arbitrary extensions to the module. For example, if an `%insert` directive is
embedded within a class `%extend`, new type-bound procedures can be manually
added to the derived type.

<table>
<thead>
<tr><th>Name</th><th>Description</th></tr>
<tr><th colspan=2>C++ WRAPPER CODE</th></tr>
</thead>
<tbody>
<tr><td><code>begin   </code></td><td>Immediately below SWIG header comment </td></tr>
<tr><td><code>runtime </code></td><td>Run time code (beginning of .cxx file)</td></tr>
<tr><td><code>header  </code></td><td>Header code (after runtime)           </td></tr>
<tr><td><code>wrapper </code></td><td>C++ wrapper code (middle of .cxx file)</td></tr>
<tr><td><code>init    </code></td><td>Initialization code (end of .cxx file)</td></tr>
</tbody>
<thead>
<tr><th colspan=2>FORTRAN WRAPPER CODE</th></tr>
</thead>
<tbody>
<tr><td><code>fbegin     </code></td><td>Code before the `module` statement </td></tr>
<tr><td><code>fmodule    </code></td><td>Start of module:                   </td></tr>
<tr><td><code>fpublic    </code></td><td>Public interface functions         </td></tr>
<tr><td><code>fparams    </code></td><td>Enums and parameters               </td></tr>
<tr><td><code>ftypes     </code></td><td>Fortran classes                    </td></tr>
<tr><td><code>finterfaces</code></td><td>Fortran class constructors         </td></tr>
<tr><td><code>fwrapper   </code></td><td>Fortran subroutines (proxy code)   </td></tr>
</tbody>
</table>

The generated C++ wrapper file looks like:
```c++
{begin}
{runtime}
{header}
#ifdef __cplusplus
extern "C" {
#endif
{wrapper}
#ifdef __cplusplus
}
#endif
{init}
```

The generated Fortran module looks like:

```fortran
{fbegin}
module [MODULE_NAME]
 use, intrinsic :: ISO_C_BINDING
 {fmodule}
 implicit none
 private
 {fpublic}
 ! module generic interfaces
 {fparams}
 {ftypes}
interface
 {finterfaces}
end interface
contains
 {fwrapper}
end module
```

## Known Issues

A number of known limitations to the SWIG Fortran module are tracked at
https://github.com/sethrj/swig/issues/59 .
